type GaugeBinding {
  minimum: Float
  maximum: Float
  optimum: Float
  impossible: Float
  approximate: Boolean
  lastTimestamp: Date
  lastValue: Float
}

input GaugeBindingInput {
  minimum: Float
  maximum: Float
  optimum: Float
  impossible: Float
  approximate: Boolean
}

type Section {
  id: ID!
  name: String!
  description: String
  season: String
  seasonNumeric: [Int]

  region: Region
  river: River

  gauge: Gauge
  levels: GaugeBinding
  flows: GaugeBinding
  flowsText: String

  putIn: Point!
  takeOut: Point!
  shape: [[Float!]]!
  distance: Float
  drop: Float
  duration: Int
  difficulty: Float!
  difficultyXtra: String
  rating: Float
  #Supply tags
  #supplyTags: [Tag],
  #Kayaking description tags
  #kayakingTags: [Tag],
  #Hazards tags
  #hazardsTags: [Tag],
  #Misc tags
  #miscTags: [Tag],
  createdAt: Date
  updatedAt: Date
  # createdBy: User
  # media: [Media]
  # pois: [Point]
}

input SectionRiverInput {
  id: ID!
  name: String
  region: RefInput!
}

input SectionInput {
  id: ID
  name: String!
  description: String
  season: String
  seasonNumeric: [Int]

  river: SectionRiverInput
  gauge: RefInput
  levels: GaugeBindingInput
  flows: GaugeBindingInput
  flowsText: String

  shape: [[Float!]]!
  distance: Float
  drop: Float
  duration: Int
  difficulty: Float!
  difficultyXtra: String
  rating: Float
#  supply: [String]
#  kayaking: [String]
#  hazards: [String]
#  tags: [String]
#  media: [MediaInput]
#  pois: [PointInput]

  # supplyTags: [RefInput]
  # kayakingTags: [RefInput]
  # hazardsTags: [RefInput]
  # miscTags: [RefInput]
}

input TagsSearch {
  _id: ID,
  selection: Int,
}

input SectionSearchTerms {
  sortBy: String
  sortDirection: SortDirection
  riverId: ID
  regionId: ID
  searchString: String
  difficulty: [Float]
  duration: [Int]
  seasonNumeric: [Int]
  rating: Float
#  kayakingTags: [TagsSearch]
#  hazardsTags: [TagsSearch
#  miscTags: [TagsSearch]
#  supplyTags: [TagsSearch]
  updatedAt: Date
}

type SectionsList {
  nodes: [Section]!
  count: Int!
}

type Query {
  sections(terms:SectionSearchTerms!, skip: Int, limit: Int, language: String): SectionsList!
  section(id:ID, language: String):Section
}

type Mutation {
  upsertSection(section:SectionInput!, language:String):Section,
  removeSection(_id:ID!):Boolean,
}

type Subscription {
  measurementsUpdated(regionId: ID!, sectionId: ID): [Section]!
}