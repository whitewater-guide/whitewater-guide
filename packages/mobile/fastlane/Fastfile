fastlane_require 'json'
fastlane_require 'spaceship'

lane :bump_build_numbers do
  appJsonFile = File.read("../app.json")
  appJson = JSON.parse(appJsonFile)
  appJson["androidBuildNumber"] = appJson["androidBuildNumber"] + 1
  appJson["iosBuildNumber"] = appJson["iosBuildNumber"] + 1
  File.open("../app.json","w") do |f|
    f.write(JSON.pretty_generate(appJson) + "\n")
  end
end

# Check Git Status
private_lane :check_git_status do
  ensure_git_status_clean
  ensure_git_branch(
    branch: ENV["BRANCH"]
  )
end

private_lane :parse_package_json do
  packageJsonFile = File.read("../package.json")
  packageJson = JSON.parse(packageJsonFile)
  version = packageJson["version"]

  appJsonFile = File.read("../app.json")
  appJson = JSON.parse(appJsonFile)

  ENV["IOS_VERSION"] = version
  ENV["ANDROID_VERSION_NAME"] = version
  ENV["IOS_VERSION_BUILD_NUMBER"] = appJson["iosBuildNumber"].to_s
  ENV["ANDROID_VERSION_CODE"] = appJson["androidBuildNumber"].to_s
end

before_all do |lane, options|
  parse_package_json
end

# IOS

platform :ios do
  private_lane :check_live_version do
    Spaceship::Tunes.login(ENV["IOS_USER_ID"])
    app = Spaceship::Tunes::Application.find(ENV["IOS_APP_IDENTIFIER"])
    liveVersion = app.live_version.version
    if ENV["IOS_VERSION"] == liveVersion
      UI.user_error!("Current iOS version (#{ENV['IOS_VERSION']}) is same as #{liveVersion}. You must bump package.json version")
    end
  end

  error do |lane, exception, options|
    path = "#{ENV['IOS_PROJECT_PATH']}/#{ENV['IOS_PLIST_PATH']}"
    if File.exist?("../#{path}.back")
      restore_file(path: path)
    end
  end

  lane :setup do |options|
    produce(
      app_name: ENV['IOS_APP_NAME'],
      app_identifier: ENV['IOS_APP_IDENTIFIER'],
      skip_itc: true
    )
    match(
      type: 'adhoc',
      shallow_clone: true,
      clone_branch_directly: true,
      force_for_new_devices: true
    )
  end

  lane :setup_push do |options|
    if options[:development]
      pem(
          output_path: "#{ENV['IOS_PROJECT_PATH']}/pem/dev",
          development: true
      )
    else
      pem(
        output_path: "#{ENV['IOS_PROJECT_PATH']}/pem",
      )
    end
  end

  lane :build do |options|
    check_git_status
    check_live_version
    plist_full_path = "#{ENV['IOS_PROJECT_PATH']}/#{ENV['IOS_PLIST_PATH']}"
    backup_file(path: plist_full_path)
    xcodeproj = "#{ENV['IOS_PROJECT_PATH']}/#{ENV['IOS_PROJECT_NAME']}.xcodeproj"
    xcworkspace = "#{ENV['IOS_PROJECT_PATH']}/#{ENV['IOS_PROJECT_NAME']}.xcworkspace"
    update_info_plist(
      xcodeproj: xcodeproj,
      plist_path: ENV['IOS_PLIST_PATH'],
      block: lambda { |plist|
        plist['CFBundleIdentifier'] = ENV['IOS_APP_IDENTIFIER']
        plist['CFBundleName'] = ENV['IOS_APP_NAME']
        plist['CFBundleDisplayName'] = ENV['IOS_APP_DISPLAY_NAME']
        plist['CFBundleShortVersionString'] = ENV['IOS_VERSION']
        plist['CFBundleVersion'] = ENV['IOS_VERSION_BUILD_NUMBER']
      },
    )
    gym(
        workspace: xcworkspace,
        configuration: options[:configuration],
        scheme: ENV['IOS_PROJECT_NAME'],
        output_directory: ENV['IOS_PROJECT_PATH']
    )
    restore_file(path: plist_full_path)
  end

  lane :code_push do |options|
    sh("yarn", "run", "appcenter", "codepush", "release-react",
       "-a", "#{ENV['APPCENTER_OWNER_NAME']}/#{ENV['APPCENTER_APP_NAME_IOS']}",
       "-t", ENV['IOS_VERSION'],
       "-d", ENV['CODEPUSH_DEPLOYMENT'],
       "--token", ENV['APPCENTER_API_TOKEN'],
     )
  end

  lane :crashlytics do |options|
    clean_build_artifacts           # Delete the local dSYM files
    download_dsyms                  # Download dSYM files from iTC
    upload_symbols_to_crashlytics(
      gsp_path: ENV['IOS_GSP_PATH'],
      binary_path: "#{ENV['IOS_PROJECT_PATH']}/Pods/Fabric/upload-symbols"
    )
  end

  lane :staging do |options|
    match(
      type: 'appstore',
      shallow_clone: true,
      clone_branch_directly: true,
      readonly: true
    )
    unless options[:skipBuild]
      build(
        configuration: 'Staging'
      )
    end
    pilot(
      ipa: ENV['IOS_IPA_PATH'],
      skip_waiting_for_build_processing: true,
    )
    code_push
  end

  lane :production do |options|
    match(
      type: 'appstore',
      shallow_clone: true,
      clone_branch_directly: true,
      readonly: true
    )
    unless options[:skipBuild]
      build(
        configuration: 'Release'
      )
    end
    deliver(
      ipa: ENV['IOS_IPA_PATH'],
      submit_for_review: false,
      skip_screenshots: true,
      skip_metadata: true,
    )
    code_push
  end

end

#  ANDROID

platform :android do
  lane :build do |options|
    check_git_status
    gradle(
      task: "assemble",
      build_type: ENV['GRADLE_BUILD_TYPE'],
      project_dir: ENV['ANDROID_PROJECT_DIR']
    )
  end

  lane :code_push do |options|
    sh(
       "yarn", "run", "appcenter", "codepush", "release-react",
       "-a", "#{ENV['APPCENTER_OWNER_NAME']}/#{ENV['APPCENTER_APP_NAME_ANDROID']}",
       "-t", ENV['ANDROID_VERSION_NAME'],
       "-d", ENV['CODEPUSH_DEPLOYMENT'],
       "--token", ENV['APPCENTER_API_TOKEN'],
     )
  end

  lane :staging do |options|
    ENV['ENVFILE'] = '.env.staging' # for some reason react-native-config isn't picked from gradle
    build
    upload_to_play_store(
      package_name: ENV['ANDROID_PACKAGE_NAME'],
      track: 'production',
      apk: "#{lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]}"
    )
    code_push
  end

  lane :production do |options|
    ENV['ENVFILE'] = '.env.production' # for some reason react-native-config isn't picked from gradle
    build
    upload_to_play_store(
      package_name: ENV['ANDROID_PACKAGE_NAME'],
      track: 'production',
      apk: "#{lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]}"
    )
    code_push
  end

end
