diff --git a/node_modules/react-native/Libraries/Image/RCTImageLoader.mm b/node_modules/react-native/Libraries/Image/RCTImageLoader.mm
index 3571647..8918d2b 100644
--- a/node_modules/react-native/Libraries/Image/RCTImageLoader.mm
+++ b/node_modules/react-native/Libraries/Image/RCTImageLoader.mm
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#import <objc/runtime.h>
 #import <atomic>
 #import <mach/mach_time.h>
+#import <objc/runtime.h>
 
 #import <ImageIO/ImageIO.h>
 
@@ -28,24 +28,22 @@
 
 static BOOL imagePerfInstrumentationEnabled = NO;
 
-BOOL RCTImageLoadingPerfInstrumentationEnabled(void)
-{
+BOOL RCTImageLoadingPerfInstrumentationEnabled(void) {
   return imagePerfInstrumentationEnabled;
 }
 
-void RCTEnableImageLoadingPerfInstrumentation(BOOL enabled)
-{
+void RCTEnableImageLoadingPerfInstrumentation(BOOL enabled) {
   imagePerfInstrumentationEnabled = enabled;
 }
 
-static NSInteger RCTImageBytesForImage(UIImage *image)
-{
-  NSInteger singleImageBytes = image.size.width * image.size.height * image.scale * image.scale * 4;
-  return image.images ? image.images.count * singleImageBytes : singleImageBytes;
+static NSInteger RCTImageBytesForImage(UIImage *image) {
+  NSInteger singleImageBytes =
+      image.size.width * image.size.height * image.scale * image.scale * 4;
+  return image.images ? image.images.count * singleImageBytes
+                      : singleImageBytes;
 }
 
-static uint64_t monotonicTimeGetCurrentNanoseconds(void)
-{
+static uint64_t monotonicTimeGetCurrentNanoseconds(void) {
   static struct mach_timebase_info tb_info = {0};
   static dispatch_once_t onceToken;
   dispatch_once(&onceToken, ^{
@@ -56,14 +54,14 @@ static uint64_t monotonicTimeGetCurrentNanoseconds(void)
   return (mach_absolute_time() * tb_info.numer) / tb_info.denom;
 }
 
-@interface RCTImageLoader() <NativeImageLoaderIOSSpec, RCTImageLoaderWithAttributionProtocol>
+@interface RCTImageLoader () <NativeImageLoaderIOSSpec,
+                              RCTImageLoaderWithAttributionProtocol>
 
 @end
 
 @implementation UIImage (React)
 
-- (NSInteger)reactDecodedImageBytes
-{
+- (NSInteger)reactDecodedImageBytes {
   NSNumber *imageBytes = objc_getAssociatedObject(self, _cmd);
   if (!imageBytes) {
     imageBytes = @(RCTImageBytesForImage(self));
@@ -71,15 +69,14 @@ - (NSInteger)reactDecodedImageBytes
   return [imageBytes integerValue];
 }
 
-- (void)setReactDecodedImageBytes:(NSInteger)bytes
-{
-  objc_setAssociatedObject(self, @selector(reactDecodedImageBytes), @(bytes), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
+- (void)setReactDecodedImageBytes:(NSInteger)bytes {
+  objc_setAssociatedObject(self, @selector(reactDecodedImageBytes), @(bytes),
+                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
 }
 
 @end
 
-@implementation RCTImageLoader
-{
+@implementation RCTImageLoader {
   NSArray<id<RCTImageURLLoader>> * (^_loadersProvider)(void);
   NSArray<id<RCTImageDataDecoder>> * (^_decodersProvider)(void);
   NSArray<id<RCTImageURLLoader>> *_loaders;
@@ -99,32 +96,32 @@ @implementation RCTImageLoader
 @synthesize maxConcurrentLoadingTasks = _maxConcurrentLoadingTasks;
 @synthesize maxConcurrentDecodingTasks = _maxConcurrentDecodingTasks;
 @synthesize maxConcurrentDecodingBytes = _maxConcurrentDecodingBytes;
-@synthesize turboModuleLookupDelegate = _turboModuleLookupDelegate;
+@synthesize turboModuleRegistry = _turboModuleRegistry;
 
 RCT_EXPORT_MODULE()
 
-- (instancetype)init
-{
+- (instancetype)init {
   return [self initWithRedirectDelegate:nil];
 }
 
-+ (BOOL)requiresMainQueueSetup
-{
++ (BOOL)requiresMainQueueSetup {
   return NO;
 }
 
-- (instancetype)initWithRedirectDelegate:(id<RCTImageRedirectProtocol>)redirectDelegate
-{
+- (instancetype)initWithRedirectDelegate:
+    (id<RCTImageRedirectProtocol>)redirectDelegate {
   if (self = [super init]) {
     _redirectDelegate = redirectDelegate;
   }
   return self;
 }
 
-- (instancetype)initWithRedirectDelegate:(id<RCTImageRedirectProtocol>)redirectDelegate
-                         loadersProvider:(NSArray<id<RCTImageURLLoader>> * (^)(void))getLoaders
-                        decodersProvider:(NSArray<id<RCTImageDataDecoder>> * (^)(void))getHandlers
-{
+- (instancetype)
+    initWithRedirectDelegate:(id<RCTImageRedirectProtocol>)redirectDelegate
+             loadersProvider:
+                 (NSArray<id<RCTImageURLLoader>> * (^)(void))getLoaders
+            decodersProvider:
+                (NSArray<id<RCTImageDataDecoder>> * (^)(void))getHandlers {
   if (self = [self initWithRedirectDelegate:redirectDelegate]) {
     _loadersProvider = getLoaders;
     _decodersProvider = getHandlers;
@@ -132,40 +129,38 @@ - (instancetype)initWithRedirectDelegate:(id<RCTImageRedirectProtocol>)redirectD
   return self;
 }
 
-- (void)setUp
-{
+- (void)setUp {
   // Set defaults
   _maxConcurrentLoadingTasks = _maxConcurrentLoadingTasks ?: 4;
   _maxConcurrentDecodingTasks = _maxConcurrentDecodingTasks ?: 2;
-  _maxConcurrentDecodingBytes = _maxConcurrentDecodingBytes ?: 30 * 1024 * 1024; // 30MB
+  _maxConcurrentDecodingBytes =
+      _maxConcurrentDecodingBytes ?: 30 * 1024 * 1024; // 30MB
 
-  _URLRequestQueue = dispatch_queue_create("com.facebook.react.ImageLoaderURLRequestQueue", DISPATCH_QUEUE_SERIAL);
+  _URLRequestQueue = dispatch_queue_create(
+      "com.facebook.react.ImageLoaderURLRequestQueue", DISPATCH_QUEUE_SERIAL);
 }
 
-- (float)handlerPriority
-{
+- (float)handlerPriority {
   return 2;
 }
+#pragma mark - RCTImageLoaderProtocol 1/3
 
-- (id<RCTImageCache>)imageCache
-{
+- (id<RCTImageCache>)imageCache {
   if (!_imageCache) {
-    //set up with default cache
+    // set up with default cache
     _imageCache = [RCTImageCache new];
   }
   return _imageCache;
 }
 
-- (void)setImageCache:(id<RCTImageCache>)cache
-{
+- (void)setImageCache:(id<RCTImageCache>)cache {
   if (_imageCache) {
     RCTLogWarn(@"RCTImageCache was already set and has now been overridden.");
   }
   _imageCache = cache;
 }
 
-- (id<RCTImageURLLoader>)imageURLLoaderForURL:(NSURL *)URL
-{
+- (id<RCTImageURLLoader>)imageURLLoaderForURL:(NSURL *)URL {
   if (!_maxConcurrentLoadingTasks) {
     [self setUp];
   }
@@ -176,13 +171,20 @@ - (void)setImageCache:(id<RCTImageCache>)cache
     if (_loadersProvider) {
       _loaders = _loadersProvider();
     } else {
-      RCTAssert(_bridge, @"Trying to find RCTImageURLLoaders and bridge not set.");
-      _loaders = [_bridge modulesConformingToProtocol:@protocol(RCTImageURLLoader)];
+      RCTAssert(_bridge,
+                @"Trying to find RCTImageURLLoaders and bridge not set.");
+      _loaders =
+          [_bridge modulesConformingToProtocol:@protocol(RCTImageURLLoader)];
     }
 
-    _loaders = [_loaders sortedArrayUsingComparator:^NSComparisonResult(id<RCTImageURLLoader> a, id<RCTImageURLLoader> b) {
-      float priorityA = [a respondsToSelector:@selector(loaderPriority)] ? [a loaderPriority] : 0;
-      float priorityB = [b respondsToSelector:@selector(loaderPriority)] ? [b loaderPriority] : 0;
+    _loaders = [_loaders sortedArrayUsingComparator:^NSComparisonResult(
+                             id<RCTImageURLLoader> a, id<RCTImageURLLoader> b) {
+      float priorityA = [a respondsToSelector:@selector(loaderPriority)]
+                            ? [a loaderPriority]
+                            : 0;
+      float priorityB = [b respondsToSelector:@selector(loaderPriority)]
+                            ? [b loaderPriority]
+                            : 0;
       if (priorityA > priorityB) {
         return NSOrderedAscending;
       } else if (priorityA < priorityB) {
@@ -198,17 +200,20 @@ - (void)setImageCache:(id<RCTImageCache>)cache
     float previousPriority = 0;
     id<RCTImageURLLoader> previousLoader = nil;
     for (id<RCTImageURLLoader> loader in _loaders) {
-      float priority = [loader respondsToSelector:@selector(loaderPriority)] ? [loader loaderPriority] : 0;
+      float priority = [loader respondsToSelector:@selector(loaderPriority)]
+                           ? [loader loaderPriority]
+                           : 0;
       if (previousLoader && priority < previousPriority) {
         return previousLoader;
       }
       if ([loader canLoadImageURL:URL]) {
         if (previousLoader) {
           if (priority == previousPriority) {
-            RCTLogError(@"The RCTImageURLLoaders %@ and %@ both reported that"
-                        " they can load the URL %@, and have equal priority"
-                        " (%g). This could result in non-deterministic behavior.",
-                        loader, previousLoader, URL, priority);
+            RCTLogError(
+                @"The RCTImageURLLoaders %@ and %@ both reported that"
+                 " they can load the URL %@, and have equal priority"
+                 " (%g). This could result in non-deterministic behavior.",
+                loader, previousLoader, URL, priority);
           }
         } else {
           previousLoader = loader;
@@ -228,8 +233,9 @@ - (void)setImageCache:(id<RCTImageCache>)cache
   return nil;
 }
 
-- (id<RCTImageDataDecoder>)imageDataDecoderForData:(NSData *)data
-{
+#pragma mark - Private Image Decoding & Resizing
+
+- (id<RCTImageDataDecoder>)imageDataDecoderForData:(NSData *)data {
   if (!_maxConcurrentLoadingTasks) {
     [self setUp];
   }
@@ -240,21 +246,30 @@ - (void)setImageCache:(id<RCTImageCache>)cache
     if (_decodersProvider) {
       _decoders = _decodersProvider();
     } else {
-      RCTAssert(_bridge, @"Trying to find RCTImageDataDecoders and bridge not set.");
-      _decoders = [_bridge modulesConformingToProtocol:@protocol(RCTImageDataDecoder)];
+      RCTAssert(_bridge,
+                @"Trying to find RCTImageDataDecoders and bridge not set.");
+      _decoders =
+          [_bridge modulesConformingToProtocol:@protocol(RCTImageDataDecoder)];
     }
 
-    _decoders = [[_bridge modulesConformingToProtocol:@protocol(RCTImageDataDecoder)] sortedArrayUsingComparator:^NSComparisonResult(id<RCTImageDataDecoder> a, id<RCTImageDataDecoder> b) {
-      float priorityA = [a respondsToSelector:@selector(decoderPriority)] ? [a decoderPriority] : 0;
-      float priorityB = [b respondsToSelector:@selector(decoderPriority)] ? [b decoderPriority] : 0;
-      if (priorityA > priorityB) {
-        return NSOrderedAscending;
-      } else if (priorityA < priorityB) {
-        return NSOrderedDescending;
-      } else {
-        return NSOrderedSame;
-      }
-    }];
+    _decoders = [[_bridge
+        modulesConformingToProtocol:@protocol(RCTImageDataDecoder)]
+        sortedArrayUsingComparator:^NSComparisonResult(
+            id<RCTImageDataDecoder> a, id<RCTImageDataDecoder> b) {
+          float priorityA = [a respondsToSelector:@selector(decoderPriority)]
+                                ? [a decoderPriority]
+                                : 0;
+          float priorityB = [b respondsToSelector:@selector(decoderPriority)]
+                                ? [b decoderPriority]
+                                : 0;
+          if (priorityA > priorityB) {
+            return NSOrderedAscending;
+          } else if (priorityA < priorityB) {
+            return NSOrderedDescending;
+          } else {
+            return NSOrderedSame;
+          }
+        }];
   }
 
   if (RCT_DEBUG) {
@@ -262,7 +277,9 @@ - (void)setImageCache:(id<RCTImageCache>)cache
     float previousPriority = 0;
     id<RCTImageDataDecoder> previousDecoder = nil;
     for (id<RCTImageDataDecoder> decoder in _decoders) {
-      float priority = [decoder respondsToSelector:@selector(decoderPriority)] ? [decoder decoderPriority] : 0;
+      float priority = [decoder respondsToSelector:@selector(decoderPriority)]
+                           ? [decoder decoderPriority]
+                           : 0;
       if (previousDecoder && priority < previousPriority) {
         return previousDecoder;
       }
@@ -270,9 +287,9 @@ - (void)setImageCache:(id<RCTImageCache>)cache
         if (previousDecoder) {
           if (priority == previousPriority) {
             RCTLogError(@"The RCTImageDataDecoders %@ and %@ both reported that"
-                        " they can decode the data <NSData %p; %tu bytes>, and"
-                        " have equal priority (%g). This could result in"
-                        " non-deterministic behavior.",
+                         " they can decode the data <NSData %p; %tu bytes>, and"
+                         " have equal priority (%g). This could result in"
+                         " non-deterministic behavior.",
                         decoder, previousDecoder, data, data.length, priority);
           }
         } else {
@@ -293,86 +310,121 @@ - (void)setImageCache:(id<RCTImageCache>)cache
   return nil;
 }
 
-static UIImage *RCTResizeImageIfNeeded(UIImage *image,
-                                       CGSize size,
+static UIImage *RCTResizeImageIfNeeded(UIImage *image, CGSize size,
                                        CGFloat scale,
-                                       RCTResizeMode resizeMode)
-{
+                                       RCTResizeMode resizeMode) {
   if (CGSizeEqualToSize(size, CGSizeZero) ||
       CGSizeEqualToSize(image.size, CGSizeZero) ||
       CGSizeEqualToSize(image.size, size)) {
     return image;
   }
   CGRect targetSize = RCTTargetRect(image.size, size, scale, resizeMode);
-  CGAffineTransform transform = RCTTransformFromTargetRect(image.size, targetSize);
+  CGAffineTransform transform =
+      RCTTransformFromTargetRect(image.size, targetSize);
   image = RCTTransformImage(image, size, scale, transform);
   return image;
 }
 
-- (RCTImageLoaderCancellationBlock) loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
-                                                   callback:(RCTImageLoaderCompletionBlock)callback
-{
+#pragma mark - RCTImageLoaderProtocol 2/3
+
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                   callback:(RCTImageLoaderCompletionBlock)callback {
+  return [self loadImageWithURLRequest:imageURLRequest
+                              priority:RCTImageLoaderPriorityImmediate
+                              callback:callback];
+}
+
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                   priority:(RCTImageLoaderPriority)priority
+                   callback:(RCTImageLoaderCompletionBlock)callback {
   return [self loadImageWithURLRequest:imageURLRequest
                                   size:CGSizeZero
                                  scale:1
                                clipped:YES
                             resizeMode:RCTResizeModeStretch
+                              priority:priority
                          progressBlock:nil
                       partialLoadBlock:nil
                        completionBlock:callback];
 }
 
-- (RCTImageLoaderCancellationBlock)loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
-                                                      size:(CGSize)size
-                                                     scale:(CGFloat)scale
-                                                   clipped:(BOOL)clipped
-                                                resizeMode:(RCTResizeMode)resizeMode
-                                             progressBlock:(RCTImageLoaderProgressBlock)progressBlock
-                                          partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
-                                           completionBlock:(RCTImageLoaderCompletionBlock)completionBlock
-{
-  RCTImageURLLoaderRequest *request = [self loadImageWithURLRequest:imageURLRequest
-                                                               size:size
-                                                              scale:scale
-                                                            clipped:clipped
-                                                         resizeMode:resizeMode
-                                                        attribution:{}
-                                                      progressBlock:progressBlock
-                                                   partialLoadBlock:partialLoadBlock
-                                                    completionBlock:completionBlock];
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                       size:(CGSize)size
+                      scale:(CGFloat)scale
+                    clipped:(BOOL)clipped
+                 resizeMode:(RCTResizeMode)resizeMode
+              progressBlock:(RCTImageLoaderProgressBlock)progressBlock
+           partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
+            completionBlock:(RCTImageLoaderCompletionBlock)completionBlock {
+  return [self loadImageWithURLRequest:imageURLRequest
+                                  size:size
+                                 scale:scale
+                               clipped:clipped
+                            resizeMode:resizeMode
+                              priority:RCTImageLoaderPriorityImmediate
+                         progressBlock:progressBlock
+                      partialLoadBlock:partialLoadBlock
+                       completionBlock:completionBlock];
+}
+
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                       size:(CGSize)size
+                      scale:(CGFloat)scale
+                    clipped:(BOOL)clipped
+                 resizeMode:(RCTResizeMode)resizeMode
+                   priority:(RCTImageLoaderPriority)priority
+              progressBlock:(RCTImageLoaderProgressBlock)progressBlock
+           partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
+            completionBlock:(RCTImageLoaderCompletionBlock)completionBlock {
+  RCTImageURLLoaderRequest *request =
+      [self loadImageWithURLRequest:imageURLRequest
+                               size:size
+                              scale:scale
+                            clipped:clipped
+                         resizeMode:resizeMode
+                           priority:priority
+                        attribution:{}
+                      progressBlock:progressBlock
+                   partialLoadBlock:partialLoadBlock
+                    completionBlock:completionBlock];
   return ^{
     [request cancel];
   };
 }
 
-- (void)dequeueTasks
-{
+#pragma mark - Private Downloader Methods
+
+- (void)dequeueTasks {
   dispatch_async(_URLRequestQueue, ^{
     // Remove completed tasks
     NSMutableArray *tasksToRemove = nil;
     for (RCTNetworkTask *task in self->_pendingTasks.reverseObjectEnumerator) {
       switch (task.status) {
-        case RCTNetworkTaskFinished:
+      case RCTNetworkTaskFinished:
+        if (!tasksToRemove) {
+          tasksToRemove = [NSMutableArray new];
+        }
+        [tasksToRemove addObject:task];
+        self->_activeTasks--;
+        break;
+      case RCTNetworkTaskPending:
+        break;
+      case RCTNetworkTaskInProgress:
+        // Check task isn't "stuck"
+        if (task.requestToken == nil) {
+          RCTLogWarn(@"Task orphaned for request %@", task.request);
           if (!tasksToRemove) {
             tasksToRemove = [NSMutableArray new];
           }
           [tasksToRemove addObject:task];
           self->_activeTasks--;
-          break;
-        case RCTNetworkTaskPending:
-          break;
-        case RCTNetworkTaskInProgress:
-          // Check task isn't "stuck"
-          if (task.requestToken == nil) {
-            RCTLogWarn(@"Task orphaned for request %@", task.request);
-            if (!tasksToRemove) {
-              tasksToRemove = [NSMutableArray new];
-            }
-            [tasksToRemove addObject:task];
-            self->_activeTasks--;
-            [task cancel];
-          }
-          break;
+          [task cancel];
+        }
+        break;
       }
     }
 
@@ -381,9 +433,11 @@ - (void)dequeueTasks
     }
 
     // Start queued decode
-    NSInteger activeDecodes = self->_scheduledDecodes - self->_pendingDecodes.count;
-    while (activeDecodes == 0 || (self->_activeBytes <= self->_maxConcurrentDecodingBytes &&
-                                  activeDecodes <= self->_maxConcurrentDecodingTasks)) {
+    NSInteger activeDecodes =
+        self->_scheduledDecodes - self->_pendingDecodes.count;
+    while (activeDecodes == 0 ||
+           (self->_activeBytes <= self->_maxConcurrentDecodingBytes &&
+            activeDecodes <= self->_maxConcurrentDecodingTasks)) {
       dispatch_block_t decodeBlock = self->_pendingDecodes.firstObject;
       if (decodeBlock) {
         [self->_pendingDecodes removeObjectAtIndex:0];
@@ -395,7 +449,8 @@ - (void)dequeueTasks
 
     // Start queued tasks
     for (RCTNetworkTask *task in self->_pendingTasks) {
-      if (MAX(self->_activeTasks, self->_scheduledDecodes) >= self->_maxConcurrentLoadingTasks) {
+      if (MAX(self->_activeTasks, self->_scheduledDecodes) >=
+          self->_maxConcurrentLoadingTasks) {
         break;
       }
       if (task.status == RCTNetworkTaskPending) {
@@ -411,15 +466,21 @@ - (void)dequeueTasks
  * path taken. This is useful if you want to skip decoding, e.g. when preloading
  * the image, or retrieving metadata.
  */
-- (RCTImageURLLoaderRequest *)_loadImageOrDataWithURLRequest:(NSURLRequest *)request
-                                                        size:(CGSize)size
-                                                       scale:(CGFloat)scale
-                                                  resizeMode:(RCTResizeMode)resizeMode
-                                                 attribution:(const ImageURLLoaderAttribution &)attribution
-                                               progressBlock:(RCTImageLoaderProgressBlock)progressHandler
-                                            partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadHandler
-                                             completionBlock:(void (^)(NSError *error, id imageOrData, BOOL cacheResult, NSURLResponse *response))completionBlock
-{
+- (RCTImageURLLoaderRequest *)
+    _loadImageOrDataWithURLRequest:(NSURLRequest *)request
+                              size:(CGSize)size
+                             scale:(CGFloat)scale
+                        resizeMode:(RCTResizeMode)resizeMode
+                          priority:(RCTImageLoaderPriority)priority
+                       attribution:
+                           (const ImageURLLoaderAttribution &)attribution
+                     progressBlock:(RCTImageLoaderProgressBlock)progressHandler
+                  partialLoadBlock:
+                      (RCTImageLoaderPartialLoadBlock)partialLoadHandler
+                   completionBlock:
+                       (void (^)(NSError *error, id imageOrData,
+                                 BOOL cacheResult,
+                                 NSURLResponse *response))completionBlock {
   {
     NSMutableURLRequest *mutableRequest = [request mutableCopy];
     [NSURLProtocol setProperty:@"RCTImageLoader"
@@ -431,73 +492,90 @@ - (RCTImageURLLoaderRequest *)_loadImageOrDataWithURLRequest:(NSURLRequest *)req
       mutableRequest.URL = [request.URL URLByAppendingPathExtension:@"png"];
     }
     if (_redirectDelegate != nil) {
-      mutableRequest.URL = [_redirectDelegate redirectAssetsURL:mutableRequest.URL];
+      mutableRequest.URL =
+          [_redirectDelegate redirectAssetsURL:mutableRequest.URL];
     }
     request = mutableRequest;
   }
 
-  // Create a copy here so the value is retained when accessed in the blocks below.
+  // Create a copy here so the value is retained when accessed in the blocks
+  // below.
   ImageURLLoaderAttribution attributionCopy(attribution);
 
   // Find suitable image URL loader
   id<RCTImageURLLoader> loadHandler = [self imageURLLoaderForURL:request.URL];
-  BOOL requiresScheduling = [loadHandler respondsToSelector:@selector(requiresScheduling)] ?
-  [loadHandler requiresScheduling] : YES;
+  BOOL requiresScheduling =
+      [loadHandler respondsToSelector:@selector(requiresScheduling)]
+          ? [loadHandler requiresScheduling]
+          : YES;
 
-  BOOL cacheResult = [loadHandler respondsToSelector:@selector(shouldCacheLoadedImages)] ?
-  [loadHandler shouldCacheLoadedImages] : YES;
+  BOOL cacheResult =
+      [loadHandler respondsToSelector:@selector(shouldCacheLoadedImages)]
+          ? [loadHandler shouldCacheLoadedImages]
+          : YES;
 
   auto cancelled = std::make_shared<std::atomic<int>>(0);
   __block dispatch_block_t cancelLoad = nil;
   __block NSLock *cancelLoadLock = [NSLock new];
-  NSString *requestId = [NSString stringWithFormat:@"%@-%llu",[[NSUUID UUID] UUIDString], monotonicTimeGetCurrentNanoseconds()];
+  NSString *requestId =
+      [NSString stringWithFormat:@"%@-%llu", [[NSUUID UUID] UUIDString],
+                                 monotonicTimeGetCurrentNanoseconds()];
 
-  void (^completionHandler)(NSError *, id, NSURLResponse *) = ^(NSError *error, id imageOrData, NSURLResponse *response) {
-    [cancelLoadLock lock];
-    cancelLoad = nil;
-    [cancelLoadLock unlock];
+  void (^completionHandler)(NSError *, id, NSURLResponse *) =
+      ^(NSError *error, id imageOrData, NSURLResponse *response) {
+        [cancelLoadLock lock];
+        cancelLoad = nil;
+        [cancelLoadLock unlock];
 
-    // If we've received an image, we should try to set it synchronously,
-    // if it's data, do decoding on a background thread.
-    if (RCTIsMainQueue() && ![imageOrData isKindOfClass:[UIImage class]]) {
-      // Most loaders do not return on the main thread, so caller is probably not
-      // expecting it, and may do expensive post-processing in the callback
-      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        if (!std::atomic_load(cancelled.get())) {
+        // If we've received an image, we should try to set it synchronously,
+        // if it's data, do decoding on a background thread.
+        if (RCTIsMainQueue() && ![imageOrData isKindOfClass:[UIImage class]]) {
+          // Most loaders do not return on the main thread, so caller is
+          // probably not expecting it, and may do expensive post-processing in
+          // the callback
+          dispatch_async(
+              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
+                if (!std::atomic_load(cancelled.get())) {
+                  completionBlock(error, imageOrData, cacheResult, response);
+                }
+              });
+        } else if (!std::atomic_load(cancelled.get())) {
           completionBlock(error, imageOrData, cacheResult, response);
         }
-      });
-    } else if (!std::atomic_load(cancelled.get())) {
-      completionBlock(error, imageOrData, cacheResult, response);
-    }
-  };
+      };
 
   // If the loader doesn't require scheduling we call it directly on
   // the main queue.
   if (loadHandler && !requiresScheduling) {
-    if ([loadHandler conformsToProtocol:@protocol(RCTImageURLLoaderWithAttribution)]) {
-      return [(id<RCTImageURLLoaderWithAttribution>)loadHandler loadImageForURL:request.URL
-                                                                           size:size
-                                                                          scale:scale
-                                                                     resizeMode:resizeMode
-                                                                      requestId:requestId
-                                                                    attribution:attributionCopy
-                                                                progressHandler:progressHandler
-                                                             partialLoadHandler:partialLoadHandler
-                                                              completionHandler:^(NSError *error, UIImage *image) {
-                                                                completionHandler(error, image, nil);
-                                                              }];
+    if ([loadHandler
+            conformsToProtocol:@protocol(RCTImageURLLoaderWithAttribution)]) {
+      return [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+             loadImageForURL:request.URL
+                        size:size
+                       scale:scale
+                  resizeMode:resizeMode
+                   requestId:requestId
+                    priority:priority
+                 attribution:attributionCopy
+             progressHandler:progressHandler
+          partialLoadHandler:partialLoadHandler
+           completionHandler:^(NSError *error, UIImage *image) {
+             completionHandler(error, image, nil);
+           }];
     }
-    RCTImageLoaderCancellationBlock cb = [loadHandler loadImageForURL:request.URL
-                                                                 size:size
-                                                                scale:scale
-                                                           resizeMode:resizeMode
-                                                      progressHandler:progressHandler
-                                                   partialLoadHandler:partialLoadHandler
-                                                    completionHandler:^(NSError *error, UIImage *image) {
-                                                      completionHandler(error, image, nil);
-                                                    }];
-    return [[RCTImageURLLoaderRequest alloc] initWithRequestId:nil imageURL:request.URL cancellationBlock:cb];
+    RCTImageLoaderCancellationBlock cb =
+        [loadHandler loadImageForURL:request.URL
+                                size:size
+                               scale:scale
+                          resizeMode:resizeMode
+                     progressHandler:progressHandler
+                  partialLoadHandler:partialLoadHandler
+                   completionHandler:^(NSError *error, UIImage *image) {
+                     completionHandler(error, image, nil);
+                   }];
+    return [[RCTImageURLLoaderRequest alloc] initWithRequestId:nil
+                                                      imageURL:request.URL
+                                             cancellationBlock:cb];
   }
 
   // All access to URL cache must be serialized
@@ -508,35 +586,40 @@ - (RCTImageURLLoaderRequest *)_loadImageOrDataWithURLRequest:(NSURLRequest *)req
   __weak RCTImageLoader *weakSelf = self;
   dispatch_async(_URLRequestQueue, ^{
     __typeof(self) strongSelf = weakSelf;
-  if (atomic_load(cancelled.get()) || !strongSelf) {
-    return;
+    if (atomic_load(cancelled.get()) || !strongSelf) {
+      return;
     }
 
     if (loadHandler) {
       dispatch_block_t cancelLoadLocal;
-      if ([loadHandler conformsToProtocol:@protocol(RCTImageURLLoaderWithAttribution)]) {
-        RCTImageURLLoaderRequest *loaderRequest = [(id<RCTImageURLLoaderWithAttribution>)loadHandler loadImageForURL:request.URL
-                                                                                                                size:size
-                                                                                                               scale:scale
-                                                                                                          resizeMode:resizeMode
-                                                                                                           requestId:requestId
-                                                                                                         attribution:attributionCopy
-                                                                                                     progressHandler:progressHandler
-                                                                                                  partialLoadHandler:partialLoadHandler
-                                                                                                   completionHandler:^(NSError *error, UIImage *image) {
-                                                                                                     completionHandler(error, image, nil);
-                                                                                                   }];
+      if ([loadHandler
+              conformsToProtocol:@protocol(RCTImageURLLoaderWithAttribution)]) {
+        RCTImageURLLoaderRequest *loaderRequest =
+            [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+                   loadImageForURL:request.URL
+                              size:size
+                             scale:scale
+                        resizeMode:resizeMode
+                         requestId:requestId
+                          priority:priority
+                       attribution:attributionCopy
+                   progressHandler:progressHandler
+                partialLoadHandler:partialLoadHandler
+                 completionHandler:^(NSError *error, UIImage *image) {
+                   completionHandler(error, image, nil);
+                 }];
         cancelLoadLocal = loaderRequest.cancellationBlock;
       } else {
-       cancelLoadLocal = [loadHandler loadImageForURL:request.URL
-                                                 size:size
-                                                scale:scale
-                                           resizeMode:resizeMode
-                                      progressHandler:progressHandler
-                                   partialLoadHandler:partialLoadHandler
-                                    completionHandler:^(NSError *error, UIImage *image) {
-                                      completionHandler(error, image, nil);
-                                    }];
+        cancelLoadLocal =
+            [loadHandler loadImageForURL:request.URL
+                                    size:size
+                                   scale:scale
+                              resizeMode:resizeMode
+                         progressHandler:progressHandler
+                      partialLoadHandler:partialLoadHandler
+                       completionHandler:^(NSError *error, UIImage *image) {
+                         completionHandler(error, image, nil);
+                       }];
       }
       [cancelLoadLock lock];
       cancelLoad = cancelLoadLocal;
@@ -554,9 +637,10 @@ - (RCTImageURLLoaderRequest *)_loadImageOrDataWithURLRequest:(NSURLRequest *)req
         completionHandler(nil, image, nil);
       } else {
         // Use networking module to load image
-        dispatch_block_t cancelLoadLocal = [strongSelf _loadURLRequest:request
-                                                         progressBlock:progressHandler
-                                                       completionBlock:completionHandler];
+        dispatch_block_t cancelLoadLocal =
+            [strongSelf _loadURLRequest:request
+                          progressBlock:progressHandler
+                        completionBlock:completionHandler];
         [cancelLoadLock lock];
         cancelLoad = cancelLoadLocal;
         [cancelLoadLock unlock];
@@ -564,56 +648,64 @@ - (RCTImageURLLoaderRequest *)_loadImageOrDataWithURLRequest:(NSURLRequest *)req
     }
   });
 
-  return [[RCTImageURLLoaderRequest alloc] initWithRequestId:requestId imageURL:request.URL cancellationBlock:^{
-    BOOL alreadyCancelled = atomic_fetch_or(cancelled.get(), 1);
-    if (alreadyCancelled) {
-      return;
-    }
-    [cancelLoadLock lock];
-    dispatch_block_t cancelLoadLocal = cancelLoad;
-    cancelLoad = nil;
-    [cancelLoadLock unlock];
-    if (cancelLoadLocal) {
-      cancelLoadLocal();
-    }
-  }];
+  return [[RCTImageURLLoaderRequest alloc]
+      initWithRequestId:requestId
+               imageURL:request.URL
+      cancellationBlock:^{
+        BOOL alreadyCancelled = atomic_fetch_or(cancelled.get(), 1);
+        if (alreadyCancelled) {
+          return;
+        }
+        [cancelLoadLock lock];
+        dispatch_block_t cancelLoadLocal = cancelLoad;
+        cancelLoad = nil;
+        [cancelLoadLock unlock];
+        if (cancelLoadLocal) {
+          cancelLoadLocal();
+        }
+      }];
 }
 
-- (RCTImageLoaderCancellationBlock)_loadURLRequest:(NSURLRequest *)request
-                                     progressBlock:(RCTImageLoaderProgressBlock)progressHandler
-                                   completionBlock:(void (^)(NSError *error, id imageOrData, NSURLResponse *response))completionHandler
-{
+- (RCTImageLoaderCancellationBlock)
+    _loadURLRequest:(NSURLRequest *)request
+      progressBlock:(RCTImageLoaderProgressBlock)progressHandler
+    completionBlock:(void (^)(NSError *error, id imageOrData,
+                              NSURLResponse *response))completionHandler {
   // Check if networking module is available
-  if (RCT_DEBUG && ![_bridge respondsToSelector:@selector(networking)]
-      && ![_turboModuleLookupDelegate moduleForName:"RCTNetworking"]) {
+  if (RCT_DEBUG && ![_bridge respondsToSelector:@selector(networking)] &&
+      ![_turboModuleRegistry moduleForName:"RCTNetworking"]) {
     RCTLogError(@"No suitable image URL loader found for %@. You may need to "
-                " import the RCTNetwork library in order to load images.",
+                 " import the RCTNetwork library in order to load images.",
                 request.URL.absoluteString);
     return NULL;
   }
 
   RCTNetworking *networking = [_bridge networking];
   if (!networking) {
-    networking = [_turboModuleLookupDelegate moduleForName:"RCTNetworking"];
+    networking = [_turboModuleRegistry moduleForName:"RCTNetworking"];
   }
 
   // Check if networking module can load image
   if (RCT_DEBUG && ![networking canHandleRequest:request]) {
-    RCTLogError(@"No suitable image URL loader found for %@", request.URL.absoluteString);
+    RCTLogError(@"No suitable image URL loader found for %@",
+                request.URL.absoluteString);
     return NULL;
   }
 
   // Use networking module to load image
-  RCTURLRequestCompletionBlock processResponse = ^(NSURLResponse *response, NSData *data, NSError *error) {
+  RCTURLRequestCompletionBlock processResponse = ^(
+      NSURLResponse *response, NSData *data, NSError *error) {
     // Check for system errors
     if (error) {
       completionHandler(error, nil, response);
       return;
     } else if (!response) {
-      completionHandler(RCTErrorWithMessage(@"Response metadata error"), nil, response);
+      completionHandler(RCTErrorWithMessage(@"Response metadata error"), nil,
+                        response);
       return;
     } else if (!data) {
-      completionHandler(RCTErrorWithMessage(@"Unknown image download error"), nil, response);
+      completionHandler(RCTErrorWithMessage(@"Unknown image download error"),
+                        nil, response);
       return;
     }
 
@@ -621,11 +713,13 @@ - (RCTImageLoaderCancellationBlock)_loadURLRequest:(NSURLRequest *)request
     if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
       NSInteger statusCode = ((NSHTTPURLResponse *)response).statusCode;
       if (statusCode != 200) {
-        NSString *errorMessage = [NSString stringWithFormat:@"Failed to load %@", response.URL];
-        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: errorMessage};
+        NSString *errorMessage =
+            [NSString stringWithFormat:@"Failed to load %@", response.URL];
+        NSDictionary *userInfo = @{NSLocalizedDescriptionKey : errorMessage};
         completionHandler([[NSError alloc] initWithDomain:NSURLErrorDomain
                                                      code:statusCode
-                                                 userInfo:userInfo], nil, response);
+                                                 userInfo:userInfo],
+                          nil, response);
         return;
       }
     }
@@ -636,36 +730,38 @@ - (RCTImageLoaderCancellationBlock)_loadURLRequest:(NSURLRequest *)request
 
   // Download image
   __weak __typeof(self) weakSelf = self;
-  __block RCTNetworkTask *task =
-  [networking networkTaskWithRequest:request
-                     completionBlock:^(NSURLResponse *response, NSData *data, NSError *error) {
-                       __typeof(self) strongSelf = weakSelf;
-                       if (!strongSelf) {
-                         return;
-                       }
-
-                       if (error || !response || !data) {
-                         NSError *someError = nil;
-                         if (error) {
-                           someError = error;
-                         } else if (!response) {
-                           someError = RCTErrorWithMessage(@"Response metadata error");
-                         } else {
-                           someError = RCTErrorWithMessage(@"Unknown image download error");
-                         }
-                         completionHandler(someError, nil, response);
-                         [strongSelf dequeueTasks];
-                         return;
-                       }
-
-                       dispatch_async(strongSelf->_URLRequestQueue, ^{
-                         // Process image data
-                         processResponse(response, data, nil);
-
-                         // Prepare for next task
-                         [strongSelf dequeueTasks];
-                       });
-                     }];
+  __block RCTNetworkTask *task = [networking
+      networkTaskWithRequest:request
+             completionBlock:^(NSURLResponse *response, NSData *data,
+                               NSError *error) {
+               __typeof(self) strongSelf = weakSelf;
+               if (!strongSelf) {
+                 return;
+               }
+
+               if (error || !response || !data) {
+                 NSError *someError = nil;
+                 if (error) {
+                   someError = error;
+                 } else if (!response) {
+                   someError = RCTErrorWithMessage(@"Response metadata error");
+                 } else {
+                   someError =
+                       RCTErrorWithMessage(@"Unknown image download error");
+                 }
+                 completionHandler(someError, nil, response);
+                 [strongSelf dequeueTasks];
+                 return;
+               }
+
+               dispatch_async(strongSelf->_URLRequestQueue, ^{
+                 // Process image data
+                 processResponse(response, data, nil);
+
+                 // Prepare for next task
+                 [strongSelf dequeueTasks];
+               });
+             }];
 
   task.downloadProgressBlock = ^(int64_t progress, int64_t total) {
     if (progressHandler) {
@@ -696,16 +792,17 @@ - (RCTImageLoaderCancellationBlock)_loadURLRequest:(NSURLRequest *)request
 
 #pragma mark - RCTImageLoaderWithAttributionProtocol
 
-- (RCTImageURLLoaderRequest *)loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
-                                                 size:(CGSize)size
-                                                scale:(CGFloat)scale
-                                              clipped:(BOOL)clipped
-                                           resizeMode:(RCTResizeMode)resizeMode
-                                          attribution:(const ImageURLLoaderAttribution &)attribution
-                                        progressBlock:(RCTImageLoaderProgressBlock)progressBlock
-                                     partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
-                                      completionBlock:(RCTImageLoaderCompletionBlock)completionBlock
-{
+- (RCTImageURLLoaderRequest *)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                       size:(CGSize)size
+                      scale:(CGFloat)scale
+                    clipped:(BOOL)clipped
+                 resizeMode:(RCTResizeMode)resizeMode
+                   priority:(RCTImageLoaderPriority)priority
+                attribution:(const ImageURLLoaderAttribution &)attribution
+              progressBlock:(RCTImageLoaderProgressBlock)progressBlock
+           partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
+            completionBlock:(RCTImageLoaderCompletionBlock)completionBlock {
   auto cancelled = std::make_shared<std::atomic<int>>(0);
   __block dispatch_block_t cancelLoad = nil;
   __block NSLock *cancelLoadLock = [NSLock new];
@@ -724,117 +821,163 @@ - (RCTImageURLLoaderRequest *)loadImageWithURLRequest:(NSURLRequest *)imageURLRe
   };
 
   __weak RCTImageLoader *weakSelf = self;
-  void (^completionHandler)(NSError *, id, BOOL, NSURLResponse *) = ^(NSError *error, id imageOrData, BOOL cacheResult, NSURLResponse *response) {
-    __typeof(self) strongSelf = weakSelf;
-    if (std::atomic_load(cancelled.get()) || !strongSelf) {
-      return;
-    }
+  void (^completionHandler)(NSError *, id, BOOL, NSURLResponse *) =
+      ^(NSError *error, id imageOrData, BOOL cacheResult,
+        NSURLResponse *response) {
+        __typeof(self) strongSelf = weakSelf;
+        if (std::atomic_load(cancelled.get()) || !strongSelf) {
+          return;
+        }
 
-    if (!imageOrData || [imageOrData isKindOfClass:[UIImage class]]) {
-      [cancelLoadLock lock];
-      cancelLoad = nil;
-      [cancelLoadLock unlock];
-      completionBlock(error, imageOrData);
-      return;
-    }
+        if (!imageOrData || [imageOrData isKindOfClass:[UIImage class]]) {
+          [cancelLoadLock lock];
+          cancelLoad = nil;
+          [cancelLoadLock unlock];
+          completionBlock(error, imageOrData);
+          return;
+        }
 
-    RCTImageLoaderCompletionBlock decodeCompletionHandler = ^(NSError *error_, UIImage *image) {
-      if (cacheResult && image) {
-        // Store decoded image in cache
-        [[strongSelf imageCache] addImageToCache:image
-                                             URL:imageURLRequest.URL.absoluteString
-                                            size:size
-                                           scale:scale
-                                      resizeMode:resizeMode
-                                        response:response];
-      }
-      [cancelLoadLock lock];
-      cancelLoad = nil;
-      [cancelLoadLock unlock];
-      completionBlock(error_, image);
-    };
-    dispatch_block_t cancelLoadLocal = [strongSelf decodeImageData:imageOrData
-                                                              size:size
-                                                             scale:scale
-                                                           clipped:clipped
-                                                        resizeMode:resizeMode
-                                                   completionBlock:decodeCompletionHandler];
-    [cancelLoadLock lock];
-    cancelLoad = cancelLoadLocal;
-    [cancelLoadLock unlock];
-  };
+        RCTImageLoaderCompletionBlock decodeCompletionHandler =
+            ^(NSError *error_, UIImage *image) {
+              if (cacheResult && image) {
+                // Store decoded image in cache
+                [[strongSelf imageCache]
+                    addImageToCache:image
+                                URL:imageURLRequest.URL.absoluteString
+                               size:size
+                              scale:scale
+                         resizeMode:resizeMode
+                           response:response];
+              }
+              [cancelLoadLock lock];
+              cancelLoad = nil;
+              [cancelLoadLock unlock];
+              completionBlock(error_, image);
+            };
+        dispatch_block_t cancelLoadLocal =
+            [strongSelf decodeImageData:imageOrData
+                                   size:size
+                                  scale:scale
+                                clipped:clipped
+                             resizeMode:resizeMode
+                        completionBlock:decodeCompletionHandler];
+        [cancelLoadLock lock];
+        cancelLoad = cancelLoadLocal;
+        [cancelLoadLock unlock];
+      };
 
-  RCTImageURLLoaderRequest *loaderRequest = [self _loadImageOrDataWithURLRequest:imageURLRequest
-                                                                             size:size
-                                                                            scale:scale
-                                                                       resizeMode:resizeMode
-                                                                      attribution:attribution
-                                                                    progressBlock:progressBlock
-                                                                 partialLoadBlock:partialLoadBlock
-                                                                  completionBlock:completionHandler];
+  RCTImageURLLoaderRequest *loaderRequest =
+      [self _loadImageOrDataWithURLRequest:imageURLRequest
+                                      size:size
+                                     scale:scale
+                                resizeMode:resizeMode
+                                  priority:priority
+                               attribution:attribution
+                             progressBlock:progressBlock
+                          partialLoadBlock:partialLoadBlock
+                           completionBlock:completionHandler];
   cancelLoad = loaderRequest.cancellationBlock;
-  return [[RCTImageURLLoaderRequest alloc] initWithRequestId:loaderRequest.requestId imageURL:imageURLRequest.URL cancellationBlock:cancellationBlock];
+  return [[RCTImageURLLoaderRequest alloc]
+      initWithRequestId:loaderRequest.requestId
+               imageURL:imageURLRequest.URL
+      cancellationBlock:cancellationBlock];
 }
 
-- (void)trackURLImageContentDidSetForRequest:(RCTImageURLLoaderRequest *)loaderRequest
-{
+- (void)trackURLImageContentDidSetForRequest:
+    (RCTImageURLLoaderRequest *)loaderRequest {
   if (!loaderRequest) {
     return;
   }
 
-  id<RCTImageURLLoader> loadHandler = [self imageURLLoaderForURL:loaderRequest.imageURL];
-  if ([loadHandler respondsToSelector:@selector(trackURLImageContentDidSetForRequest:)]) {
-    [(id<RCTImageURLLoaderWithAttribution>)loadHandler trackURLImageContentDidSetForRequest:loaderRequest];
+  // This delegate method is Fabric-only
+  id<RCTImageURLLoader> loadHandler =
+      [self imageURLLoaderForURL:loaderRequest.imageURL];
+  if ([loadHandler respondsToSelector:@selector
+                   (trackURLImageContentDidSetForRequest:)]) {
+    [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+        trackURLImageContentDidSetForRequest:loaderRequest];
   }
 }
 
-- (void)trackURLImageVisibilityForRequest:(RCTImageURLLoaderRequest *)loaderRequest imageView:(UIView *)imageView
-{
+- (void)trackURLImageVisibilityForRequest:
+            (RCTImageURLLoaderRequest *)loaderRequest
+                                imageView:(UIView *)imageView {
   if (!loaderRequest || !imageView) {
     return;
   }
 
-  id<RCTImageURLLoader> loadHandler = [self imageURLLoaderForURL:loaderRequest.imageURL];
-  if ([loadHandler respondsToSelector:@selector(trackURLImageVisibilityForRequest:imageView:)]) {
-    [(id<RCTImageURLLoaderWithAttribution>)loadHandler trackURLImageVisibilityForRequest:loaderRequest imageView:imageView];
+  id<RCTImageURLLoader> loadHandler =
+      [self imageURLLoaderForURL:loaderRequest.imageURL];
+  if ([loadHandler respondsToSelector:@selector
+                   (trackURLImageVisibilityForRequest:imageView:)]) {
+    [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+        trackURLImageVisibilityForRequest:loaderRequest
+                                imageView:imageView];
   }
 }
 
-- (void)trackURLImageDidDestroy:(RCTImageURLLoaderRequest *)loaderRequest
-{
+- (void)trackURLImageRequestDidDestroy:
+    (RCTImageURLLoaderRequest *)loaderRequest {
   if (!loaderRequest) {
     return;
   }
-  id<RCTImageURLLoader> loadHandler = [self imageURLLoaderForURL:loaderRequest.imageURL];
+
+  id<RCTImageURLLoader> loadHandler =
+      [self imageURLLoaderForURL:loaderRequest.imageURL];
+  if ([loadHandler
+          respondsToSelector:@selector(trackURLImageRequestDidDestroy:)]) {
+    [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+        trackURLImageRequestDidDestroy:loaderRequest];
+  }
+}
+
+- (void)trackURLImageDidDestroy:(RCTImageURLLoaderRequest *)loaderRequest {
+  if (!loaderRequest) {
+    return;
+  }
+
+  id<RCTImageURLLoader> loadHandler =
+      [self imageURLLoaderForURL:loaderRequest.imageURL];
   if ([loadHandler respondsToSelector:@selector(trackURLImageDidDestroy:)]) {
-    [(id<RCTImageURLLoaderWithAttribution>)loadHandler trackURLImageDidDestroy:loaderRequest];
+    [(id<RCTImageURLLoaderWithAttribution>)loadHandler
+        trackURLImageDidDestroy:loaderRequest];
   }
 }
 
-- (RCTImageLoaderCancellationBlock)decodeImageData:(NSData *)data
-                                              size:(CGSize)size
-                                             scale:(CGFloat)scale
-                                           clipped:(BOOL)clipped
-                                        resizeMode:(RCTResizeMode)resizeMode
-                                   completionBlock:(RCTImageLoaderCompletionBlock)completionBlock
-{
+#pragma mark - RCTImageLoaderProtocol 3/3
+
+- (RCTImageLoaderCancellationBlock)
+    decodeImageData:(NSData *)data
+               size:(CGSize)size
+              scale:(CGFloat)scale
+            clipped:(BOOL)clipped
+         resizeMode:(RCTResizeMode)resizeMode
+    completionBlock:(RCTImageLoaderCompletionBlock)completionBlock {
   if (data.length == 0) {
     completionBlock(RCTErrorWithMessage(@"No image data"), nil);
-    return ^{};
+    return ^{
+    };
   }
 
   auto cancelled = std::make_shared<std::atomic<int>>(0);
-  void (^completionHandler)(NSError *, UIImage *) = ^(NSError *error, UIImage *image) {
+  void (^completionHandler)(NSError *, UIImage *) = ^(NSError *error,
+                                                      UIImage *image) {
     if (RCTIsMainQueue()) {
-      // Most loaders do not return on the main thread, so caller is probably not
-      // expecting it, and may do expensive post-processing in the callback
-      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        if (!std::atomic_load(cancelled.get())) {
-          completionBlock(error, clipped ? RCTResizeImageIfNeeded(image, size, scale, resizeMode) : image);
-        }
-      });
+      // Most loaders do not return on the main thread, so caller is probably
+      // not expecting it, and may do expensive post-processing in the callback
+      dispatch_async(
+          dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
+            if (!std::atomic_load(cancelled.get())) {
+              completionBlock(error, clipped
+                                         ? RCTResizeImageIfNeeded(
+                                               image, size, scale, resizeMode)
+                                         : image);
+            }
+          });
     } else if (!std::atomic_load(cancelled.get())) {
-      completionBlock(error, clipped ? RCTResizeImageIfNeeded(image, size, scale, resizeMode) : image);
+      completionBlock(error, clipped ? RCTResizeImageIfNeeded(image, size,
+                                                              scale, resizeMode)
+                                     : image);
     }
   };
 
@@ -844,50 +987,63 @@ - (RCTImageLoaderCancellationBlock)decodeImageData:(NSData *)data
                                     size:size
                                    scale:scale
                               resizeMode:resizeMode
-                       completionHandler:completionHandler] ?: ^{};
+                       completionHandler:completionHandler]
+               ?: ^{
+                 };
   } else {
     dispatch_block_t decodeBlock = ^{
       // Calculate the size, in bytes, that the decompressed image will require
-      NSInteger decodedImageBytes = (size.width * scale) * (size.height * scale) * 4;
+      NSInteger decodedImageBytes =
+          (size.width * scale) * (size.height * scale) * 4;
 
       // Mark these bytes as in-use
       self->_activeBytes += decodedImageBytes;
 
       // Do actual decompression on a concurrent background queue
-      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        if (!std::atomic_load(cancelled.get())) {
+      dispatch_async(
+          dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
+            if (!std::atomic_load(cancelled.get())) {
 
-          // Decompress the image data (this may be CPU and memory intensive)
-          UIImage *image = RCTDecodeImageWithData(data, size, scale, resizeMode);
+              // Decompress the image data (this may be CPU and memory
+              // intensive)
+              UIImage *image =
+                  RCTDecodeImageWithData(data, size, scale, resizeMode);
 
 #if RCT_DEV
-          CGSize imagePixelSize = RCTSizeInPixels(image.size, image.scale);
-          CGSize screenPixelSize = RCTSizeInPixels(RCTScreenSize(), RCTScreenScale());
-          if (imagePixelSize.width * imagePixelSize.height >
-              screenPixelSize.width * screenPixelSize.height) {
-            RCTLogInfo(@"[PERF ASSETS] Loading image at size %@, which is larger "
-                       "than the screen size %@", NSStringFromCGSize(imagePixelSize),
-                       NSStringFromCGSize(screenPixelSize));
-          }
+              CGSize imagePixelSize = RCTSizeInPixels(image.size, image.scale);
+              CGSize screenPixelSize =
+                  RCTSizeInPixels(RCTScreenSize(), RCTScreenScale());
+              if (imagePixelSize.width * imagePixelSize.height >
+                  screenPixelSize.width * screenPixelSize.height) {
+                RCTLogInfo(
+                    @"[PERF ASSETS] Loading image at size %@, which is larger "
+                     "than the screen size %@",
+                    NSStringFromCGSize(imagePixelSize),
+                    NSStringFromCGSize(screenPixelSize));
+              }
 #endif
 
-          if (image) {
-            completionHandler(nil, image);
-          } else {
-            NSString *errorMessage = [NSString stringWithFormat:@"Error decoding image data <NSData %p; %tu bytes>", data, data.length];
-            NSError *finalError = RCTErrorWithMessage(errorMessage);
-            completionHandler(finalError, nil);
-          }
-        }
+              if (image) {
+                completionHandler(nil, image);
+              } else {
+                NSString *errorMessage = [NSString
+                    stringWithFormat:
+                        @"Error decoding image data <NSData %p; %tu bytes>",
+                        data, data.length];
+                NSError *finalError = RCTErrorWithMessage(errorMessage);
+                completionHandler(finalError, nil);
+              }
+            }
 
-        // We're no longer retaining the uncompressed data, so now we'll mark
-        // the decoding as complete so that the loading task queue can resume.
-        dispatch_async(self->_URLRequestQueue, ^{
-          self->_scheduledDecodes--;
-          self->_activeBytes -= decodedImageBytes;
-          [self dequeueTasks];
-        });
-      });
+            // We're no longer retaining the uncompressed data, so now we'll
+            // mark the decoding as complete so that the loading task queue can
+            // resume.
+            dispatch_async(self->_URLRequestQueue, ^{
+              self->_scheduledDecodes--;
+              self->_activeBytes -= decodedImageBytes;
+              [self dequeueTasks];
+            });
+          });
     };
 
     if (!_URLRequestQueue) {
@@ -902,9 +1058,11 @@ - (RCTImageLoaderCancellationBlock)decodeImageData:(NSData *)data
       if (!self->_pendingDecodes) {
         self->_pendingDecodes = [NSMutableArray new];
       }
-      NSInteger activeDecodes = self->_scheduledDecodes - self->_pendingDecodes.count - 1;
-      if (activeDecodes == 0 || (self->_activeBytes <= self->_maxConcurrentDecodingBytes &&
-                                 activeDecodes <= self->_maxConcurrentDecodingTasks)) {
+      NSInteger activeDecodes =
+          self->_scheduledDecodes - self->_pendingDecodes.count - 1;
+      if (activeDecodes == 0 ||
+          (self->_activeBytes <= self->_maxConcurrentDecodingBytes &&
+           activeDecodes <= self->_maxConcurrentDecodingTasks)) {
         decodeBlock();
       } else {
         [self->_pendingDecodes addObject:decodeBlock];
@@ -917,71 +1075,78 @@ - (RCTImageLoaderCancellationBlock)decodeImageData:(NSData *)data
   }
 }
 
-- (RCTImageLoaderCancellationBlock)getImageSizeForURLRequest:(NSURLRequest *)imageURLRequest
-                                                       block:(void(^)(NSError *error, CGSize size))callback
-{
-  void (^completion)(NSError *, id, BOOL, NSURLResponse *) = ^(NSError *error, id imageOrData, BOOL cacheResult, NSURLResponse *response) {
-    CGSize size;
-    if ([imageOrData isKindOfClass:[NSData class]]) {
-      NSDictionary *meta = RCTGetImageMetadata(imageOrData);
-
-      NSInteger imageOrientation = [meta[(id)kCGImagePropertyOrientation] integerValue];
-      switch (imageOrientation) {
-        case kCGImagePropertyOrientationLeft:
-        case kCGImagePropertyOrientationRight:
-        case kCGImagePropertyOrientationLeftMirrored:
-        case kCGImagePropertyOrientationRightMirrored:
-          // swap width and height
-          size = (CGSize){
-            [meta[(id)kCGImagePropertyPixelHeight] floatValue],
-            [meta[(id)kCGImagePropertyPixelWidth] floatValue],
-          };
-          break;
-        case kCGImagePropertyOrientationUp:
-        case kCGImagePropertyOrientationDown:
-        case kCGImagePropertyOrientationUpMirrored:
-        case kCGImagePropertyOrientationDownMirrored:
-        default:
+- (RCTImageLoaderCancellationBlock)
+    getImageSizeForURLRequest:(NSURLRequest *)imageURLRequest
+                        block:(void (^)(NSError *error, CGSize size))callback {
+  void (^completion)(NSError *, id, BOOL, NSURLResponse *) =
+      ^(NSError *error, id imageOrData, BOOL cacheResult,
+        NSURLResponse *response) {
+        CGSize size;
+        if ([imageOrData isKindOfClass:[NSData class]]) {
+          NSDictionary *meta = RCTGetImageMetadata(imageOrData);
+
+          NSInteger imageOrientation =
+              [meta[(id)kCGImagePropertyOrientation] integerValue];
+          switch (imageOrientation) {
+          case kCGImagePropertyOrientationLeft:
+          case kCGImagePropertyOrientationRight:
+          case kCGImagePropertyOrientationLeftMirrored:
+          case kCGImagePropertyOrientationRightMirrored:
+            // swap width and height
+            size = (CGSize){
+                [meta[(id)kCGImagePropertyPixelHeight] floatValue],
+                [meta[(id)kCGImagePropertyPixelWidth] floatValue],
+            };
+            break;
+          case kCGImagePropertyOrientationUp:
+          case kCGImagePropertyOrientationDown:
+          case kCGImagePropertyOrientationUpMirrored:
+          case kCGImagePropertyOrientationDownMirrored:
+          default:
+            size = (CGSize){
+                [meta[(id)kCGImagePropertyPixelWidth] floatValue],
+                [meta[(id)kCGImagePropertyPixelHeight] floatValue],
+            };
+            break;
+          }
+        } else {
+          UIImage *image = imageOrData;
           size = (CGSize){
-            [meta[(id)kCGImagePropertyPixelWidth] floatValue],
-            [meta[(id)kCGImagePropertyPixelHeight] floatValue],
+              image.size.width * image.scale,
+              image.size.height * image.scale,
           };
-          break;
-      }
-    } else {
-      UIImage *image = imageOrData;
-      size = (CGSize){
-        image.size.width * image.scale,
-        image.size.height * image.scale,
+        }
+        callback(error, size);
       };
-    }
-    callback(error, size);
-  };
 
-  RCTImageURLLoaderRequest *loaderRequest = [self _loadImageOrDataWithURLRequest:imageURLRequest
-                                                                            size:CGSizeZero
-                                                                           scale:1
-                                                                      resizeMode:RCTResizeModeStretch
-                                                                     attribution:{}
-                                                                   progressBlock:NULL
-                                                                partialLoadBlock:NULL
-                                                                 completionBlock:completion];
+  RCTImageURLLoaderRequest *loaderRequest =
+      [self _loadImageOrDataWithURLRequest:imageURLRequest
+                                      size:CGSizeZero
+                                     scale:1
+                                resizeMode:RCTResizeModeStretch
+                                  priority:RCTImageLoaderPriorityImmediate
+                               attribution:{}
+                             progressBlock:NULL
+                          partialLoadBlock:NULL
+                           completionBlock:completion];
   return loaderRequest.cancellationBlock;
 }
 
-- (NSDictionary *)getImageCacheStatus:(NSArray *)requests
-{
+- (NSDictionary *)getImageCacheStatus:(NSArray *)requests {
   NSMutableDictionary *results = [NSMutableDictionary dictionary];
   for (id request in requests) {
     NSURLRequest *urlRequest = [RCTConvert NSURLRequest:request];
     if (urlRequest) {
-      NSCachedURLResponse *cachedResponse = [NSURLCache.sharedURLCache cachedResponseForRequest:urlRequest];
+      NSCachedURLResponse *cachedResponse =
+          [NSURLCache.sharedURLCache cachedResponseForRequest:urlRequest];
       if (cachedResponse) {
-        if (cachedResponse.storagePolicy == NSURLCacheStorageAllowedInMemoryOnly) {
+        if (cachedResponse.storagePolicy ==
+            NSURLCacheStorageAllowedInMemoryOnly) {
           results[urlRequest.URL.absoluteString] = @"memory";
         } else if (NSURLCache.sharedURLCache.currentMemoryUsage == 0) {
           // We can't check whether the file is cached on disk or memory.
-          // However, if currentMemoryUsage is disabled, it must be read from disk.
+          // However, if currentMemoryUsage is disabled, it must be read from
+          // disk.
           results[urlRequest.URL.absoluteString] = @"disk";
         } else {
           results[urlRequest.URL.absoluteString] = @"disk/memory";
@@ -994,34 +1159,33 @@ - (NSDictionary *)getImageCacheStatus:(NSArray *)requests
 
 #pragma mark - RCTURLRequestHandler
 
-- (BOOL)canHandleRequest:(NSURLRequest *)request
-{
+- (BOOL)canHandleRequest:(NSURLRequest *)request {
   NSURL *requestURL = request.URL;
 
   // If the data being loaded is a video, return NO
-  // Even better may be to implement this on the RCTImageURLLoader that would try to load it,
-  // but we'd have to run the logic both in RCTPhotoLibraryImageLoader and
-  // RCTAssetsLibraryRequestHandler. Once we drop iOS7 though, we'd drop
-  // RCTAssetsLibraryRequestHandler and can move it there.
+  // Even better may be to implement this on the RCTImageURLLoader that would
+  // try to load it, but we'd have to run the logic both in
+  // RCTPhotoLibraryImageLoader and RCTAssetsLibraryRequestHandler. Once we drop
+  // iOS7 though, we'd drop RCTAssetsLibraryRequestHandler and can move it
+  // there.
   static NSRegularExpression *videoRegex;
   static dispatch_once_t onceToken;
   dispatch_once(&onceToken, ^{
     NSError *error = nil;
-    videoRegex = [NSRegularExpression regularExpressionWithPattern:@"(?:&|^)ext=MOV(?:&|$)"
-                                                           options:NSRegularExpressionCaseInsensitive
-                                                             error:&error];
+    videoRegex = [NSRegularExpression
+        regularExpressionWithPattern:@"(?:&|^)ext=MOV(?:&|$)"
+                             options:NSRegularExpressionCaseInsensitive
+                               error:&error];
     if (error) {
       RCTLogError(@"%@", error);
     }
   });
 
   NSString *query = requestURL.query;
-  if (
-      query != nil &&
+  if (query != nil &&
       [videoRegex firstMatchInString:query
                              options:0
-                               range:NSMakeRange(0, query.length)]
-      ) {
+                               range:NSMakeRange(0, query.length)]) {
     return NO;
   }
 
@@ -1038,104 +1202,114 @@ - (BOOL)canHandleRequest:(NSURLRequest *)request
   return NO;
 }
 
-- (id)sendRequest:(NSURLRequest *)request withDelegate:(id<RCTURLRequestDelegate>)delegate
-{
+- (id)sendRequest:(NSURLRequest *)request
+     withDelegate:(id<RCTURLRequestDelegate>)delegate {
   __block RCTImageLoaderCancellationBlock requestToken;
-  requestToken = [self loadImageWithURLRequest:request callback:^(NSError *error, UIImage *image) {
-    if (error) {
-      [delegate URLRequest:requestToken didCompleteWithError:error];
-      return;
-    }
-
-    NSString *mimeType = nil;
-    NSData *imageData = nil;
-    if (RCTImageHasAlpha(image.CGImage)) {
-      mimeType = @"image/png";
-      imageData = UIImagePNGRepresentation(image);
-    } else {
-      mimeType = @"image/jpeg";
-      imageData = UIImageJPEGRepresentation(image, 1.0);
-    }
+  requestToken = [self
+      loadImageWithURLRequest:request
+                     callback:^(NSError *error, UIImage *image) {
+                       if (error) {
+                         [delegate URLRequest:requestToken
+                             didCompleteWithError:error];
+                         return;
+                       }
 
-    NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL
-                                                        MIMEType:mimeType
-                                           expectedContentLength:imageData.length
-                                                textEncodingName:nil];
+                       NSString *mimeType = nil;
+                       NSData *imageData = nil;
+                       if (RCTImageHasAlpha(image.CGImage)) {
+                         mimeType = @"image/png";
+                         imageData = UIImagePNGRepresentation(image);
+                       } else {
+                         mimeType = @"image/jpeg";
+                         imageData = UIImageJPEGRepresentation(image, 1.0);
+                       }
 
-    [delegate URLRequest:requestToken didReceiveResponse:response];
-    [delegate URLRequest:requestToken didReceiveData:imageData];
-    [delegate URLRequest:requestToken didCompleteWithError:nil];
-  }];
+                       NSURLResponse *response =
+                           [[NSURLResponse alloc] initWithURL:request.URL
+                                                     MIMEType:mimeType
+                                        expectedContentLength:imageData.length
+                                             textEncodingName:nil];
+
+                       [delegate URLRequest:requestToken
+                           didReceiveResponse:response];
+                       [delegate URLRequest:requestToken
+                             didReceiveData:imageData];
+                       [delegate URLRequest:requestToken
+                           didCompleteWithError:nil];
+                     }];
 
   return requestToken;
 }
 
-- (void)cancelRequest:(id)requestToken
-{
+- (void)cancelRequest:(id)requestToken {
   if (requestToken) {
     ((RCTImageLoaderCancellationBlock)requestToken)();
   }
 }
 
-- (std::shared_ptr<facebook::react::TurboModule>)
-    getTurboModuleWithJsInvoker:(std::shared_ptr<facebook::react::CallInvoker>)jsInvoker
-                  nativeInvoker:(std::shared_ptr<facebook::react::CallInvoker>)nativeInvoker
-                     perfLogger:(id<RCTTurboModulePerformanceLogger>)perfLogger
-{
-  return std::make_shared<facebook::react::NativeImageLoaderIOSSpecJSI>(self, jsInvoker, nativeInvoker, perfLogger);
+- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
+    (const facebook::react::ObjCTurboModule::InitParams &)params {
+  return std::make_shared<facebook::react::NativeImageLoaderIOSSpecJSI>(params);
 }
 
-RCT_EXPORT_METHOD(getSize:(NSString *)uri resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject)
-{
+RCT_EXPORT_METHOD(getSize
+                  : (NSString *)uri resolve
+                  : (RCTPromiseResolveBlock)resolve reject
+                  : (RCTPromiseRejectBlock)reject) {
   NSURLRequest *request = [RCTConvert NSURLRequest:uri];
   [self getImageSizeForURLRequest:request
-   block:^(NSError *error, CGSize size) {
-     if (error) {
-       reject(
-        @"E_GET_SIZE_FAILURE",
-        [NSString stringWithFormat: @"Failed to getSize of %@", uri],
-        error);
-     } else {
-       resolve(@[@(size.width), @(size.height)]);
-     }
-   }];
+                            block:^(NSError *error, CGSize size) {
+                              if (error) {
+                                reject(@"E_GET_SIZE_FAILURE",
+                                       [NSString
+                                           stringWithFormat:
+                                               @"Failed to getSize of %@", uri],
+                                       error);
+                              } else {
+                                resolve(@[ @(size.width), @(size.height) ]);
+                              }
+                            }];
 }
 
-RCT_EXPORT_METHOD(getSizeWithHeaders:(NSString *)uri
-                  headers:(NSDictionary *)headers
-                  resolve:(RCTPromiseResolveBlock)resolve
-                  reject:(RCTPromiseRejectBlock)reject)
-{
+RCT_EXPORT_METHOD(getSizeWithHeaders
+                  : (NSString *)uri headers
+                  : (NSDictionary *)headers resolve
+                  : (RCTPromiseResolveBlock)resolve reject
+                  : (RCTPromiseRejectBlock)reject) {
   NSURLRequest *request = [RCTConvert NSURLRequest:uri];
   [self getImageSizeForURLRequest:request
-   block:^(NSError *error, CGSize size) {
-     if (error) {
-       reject(@"E_GET_SIZE_FAILURE", nil, error);
-       return;
-     }
-     resolve(@{@"width":@(size.width),@"height":@(size.height)});
-   }];
+                            block:^(NSError *error, CGSize size) {
+                              if (error) {
+                                reject(@"E_GET_SIZE_FAILURE", nil, error);
+                                return;
+                              }
+                              resolve(@{
+                                @"width" : @(size.width),
+                                @"height" : @(size.height)
+                              });
+                            }];
 }
 
-RCT_EXPORT_METHOD(prefetchImage:(NSString *)uri
-              resolve:(RCTPromiseResolveBlock)resolve
-               reject:(RCTPromiseRejectBlock)reject)
-{
+RCT_EXPORT_METHOD(prefetchImage
+                  : (NSString *)uri resolve
+                  : (RCTPromiseResolveBlock)resolve reject
+                  : (RCTPromiseRejectBlock)reject) {
   NSURLRequest *request = [RCTConvert NSURLRequest:uri];
   [self loadImageWithURLRequest:request
-   callback:^(NSError *error, UIImage *image) {
-     if (error) {
-       reject(@"E_PREFETCH_FAILURE", nil, error);
-       return;
-     }
-     resolve(@YES);
-   }];
+                       priority:RCTImageLoaderPriorityPrefetch
+                       callback:^(NSError *error, UIImage *image) {
+                         if (error) {
+                           reject(@"E_PREFETCH_FAILURE", nil, error);
+                           return;
+                         }
+                         resolve(@YES);
+                       }];
 }
 
-RCT_EXPORT_METHOD(queryCache:(NSArray *)uris
-                  resolve:(RCTPromiseResolveBlock)resolve
-                  reject:(RCTPromiseRejectBlock)reject)
-{
+RCT_EXPORT_METHOD(queryCache
+                  : (NSArray *)uris resolve
+                  : (RCTPromiseResolveBlock)resolve reject
+                  : (RCTPromiseRejectBlock)reject) {
   resolve([self getImageCacheStatus:uris]);
 }
 @end
@@ -1146,16 +1320,13 @@ - (void)cancelRequest:(id)requestToken
  */
 @implementation RCTBridge (RCTImageLoader)
 
-- (RCTImageLoader *)imageLoader
-{
-  RCTLogWarn(@"Calling bridge.imageLoader is deprecated and will not work in newer versions of RN. Please update to the "
-             "moduleForClass API or turboModuleLookupDelegate API.");
+- (RCTImageLoader *)imageLoader {
+  RCTLogWarn(@"Calling bridge.imageLoader is deprecated and will not work in "
+             @"newer versions of RN. Please update to the "
+              "moduleForClass API or turboModuleRegistry API.");
   return [self moduleForClass:[RCTImageLoader class]];
 }
 
 @end
 
-Class RCTImageLoaderCls(void)
-{
-  return RCTImageLoader.class;
-}
+Class RCTImageLoaderCls(void) { return RCTImageLoader.class; }
diff --git a/node_modules/react-native/Libraries/Image/RCTImageLoaderProtocol.h b/node_modules/react-native/Libraries/Image/RCTImageLoaderProtocol.h
index 6b17cc7..ab63307 100644
--- a/node_modules/react-native/Libraries/Image/RCTImageLoaderProtocol.h
+++ b/node_modules/react-native/Libraries/Image/RCTImageLoaderProtocol.h
@@ -8,11 +8,11 @@
 #import <UIKit/UIKit.h>
 
 #import <React/RCTBridge.h>
-#import <React/RCTResizeMode.h>
-#import <React/RCTURLRequestHandler.h>
+#import <React/RCTImageCache.h>
 #import <React/RCTImageDataDecoder.h>
 #import <React/RCTImageURLLoader.h>
-#import <React/RCTImageCache.h>
+#import <React/RCTResizeMode.h>
+#import <React/RCTURLRequestHandler.h>
 
 /**
  * If available, RCTImageRedirectProtocol is invoked before loading an asset.
@@ -26,7 +26,18 @@
 
 @end
 
-@protocol RCTImageLoaderProtocol<RCTURLRequestHandler>
+/**
+ * Image Downloading priority.
+ * Use PriorityImmediate to download images at the highest priority.
+ * Use PriorityPrefetch to prefetch images at a lower priority.
+ * The priority logic is up to each @RCTImageLoaderProtocol implementation
+ */
+typedef NS_ENUM(NSUInteger, RCTImageLoaderPriority) {
+  RCTImageLoaderPriorityImmediate,
+  RCTImageLoaderPriorityPrefetch
+};
+
+@protocol RCTImageLoaderProtocol <RCTURLRequestHandler>
 
 /**
  * The maximum number of concurrent image loading tasks. Loading and decoding
@@ -34,14 +45,14 @@
  * cause memory to spike. If you are seeing out-of-memory crashes, try reducing
  * this value.
  */
-@property (nonatomic, assign) NSUInteger maxConcurrentLoadingTasks;
+@property(nonatomic, assign) NSUInteger maxConcurrentLoadingTasks;
 
 /**
  * The maximum number of concurrent image decoding tasks. Decoding large
  * images can be especially CPU and memory intensive, so if your are decoding a
  * lot of large images in your app, you may wish to adjust this value.
  */
-@property (nonatomic, assign) NSUInteger maxConcurrentDecodingTasks;
+@property(nonatomic, assign) NSUInteger maxConcurrentDecodingTasks;
 
 /**
  * Decoding large images can use a lot of memory, and potentially cause the app
@@ -51,32 +62,42 @@
  * to try to decompress multiple huge images at once. Note that this value is
  * only a hint, and not an indicator of the total memory used by the app.
  */
-@property (nonatomic, assign) NSUInteger maxConcurrentDecodingBytes;
+@property(nonatomic, assign) NSUInteger maxConcurrentDecodingBytes;
 
 /**
  * Loads the specified image at the highest available resolution.
  * Can be called from any thread, will call back on an unspecified thread.
  */
-- (RCTImageLoaderCancellationBlock)loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
-                                                  callback:(RCTImageLoaderCompletionBlock)callback;
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                   callback:(RCTImageLoaderCompletionBlock)callback;
+/**
+ * As above, but includes download `priority`.
+ */
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                   priority:(RCTImageLoaderPriority)priority
+                   callback:(RCTImageLoaderCompletionBlock)callback;
 
 /**
- * As above, but includes target `size`, `scale` and `resizeMode`, which are used to
- * select the optimal dimensions for the loaded image. The `clipped` option
- * controls whether the image will be clipped to fit the specified size exactly,
- * or if the original aspect ratio should be retained.
- * `partialLoadBlock` is meant for custom image loaders that do not ship with the core RN library.
- * It is meant to be called repeatedly while loading the image as higher quality versions are decoded,
- * for instance with progressive JPEGs.
+ * As above, but includes target `size`, `scale` and `resizeMode`, which are
+ * used to select the optimal dimensions for the loaded image. The `clipped`
+ * option controls whether the image will be clipped to fit the specified size
+ * exactly, or if the original aspect ratio should be retained.
+ * `partialLoadBlock` is meant for custom image loaders that do not ship with
+ * the core RN library. It is meant to be called repeatedly while loading the
+ * image as higher quality versions are decoded, for instance with progressive
+ * JPEGs.
  */
-- (RCTImageLoaderCancellationBlock)loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
-                                                      size:(CGSize)size
-                                                     scale:(CGFloat)scale
-                                                   clipped:(BOOL)clipped
-                                                resizeMode:(RCTResizeMode)resizeMode
-                                             progressBlock:(RCTImageLoaderProgressBlock)progressBlock
-                                          partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
-                                           completionBlock:(RCTImageLoaderCompletionBlock)completionBlock;
+- (nullable RCTImageLoaderCancellationBlock)
+    loadImageWithURLRequest:(NSURLRequest *)imageURLRequest
+                       size:(CGSize)size
+                      scale:(CGFloat)scale
+                    clipped:(BOOL)clipped
+                 resizeMode:(RCTResizeMode)resizeMode
+              progressBlock:(RCTImageLoaderProgressBlock)progressBlock
+           partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadBlock
+            completionBlock:(RCTImageLoaderCompletionBlock)completionBlock;
 
 /**
  * Finds an appropriate image decoder and passes the target `size`, `scale` and
@@ -85,25 +106,28 @@
  * if the original aspect ratio should be retained. Can be called from any
  * thread, will call callback on an unspecified thread.
  */
-- (RCTImageLoaderCancellationBlock)decodeImageData:(NSData *)imageData
-                                              size:(CGSize)size
-                                             scale:(CGFloat)scale
-                                           clipped:(BOOL)clipped
-                                        resizeMode:(RCTResizeMode)resizeMode
-                                   completionBlock:(RCTImageLoaderCompletionBlock)completionBlock;
+- (RCTImageLoaderCancellationBlock)
+    decodeImageData:(NSData *)imageData
+               size:(CGSize)size
+              scale:(CGFloat)scale
+            clipped:(BOOL)clipped
+         resizeMode:(RCTResizeMode)resizeMode
+    completionBlock:(RCTImageLoaderCompletionBlock)completionBlock;
 
 /**
  * Get image size, in pixels. This method will do the least work possible to get
  * the information, and won't decode the image if it doesn't have to.
  */
-- (RCTImageLoaderCancellationBlock)getImageSizeForURLRequest:(NSURLRequest *)imageURLRequest
-                                                       block:(void(^)(NSError *error, CGSize size))completionBlock;
+- (RCTImageLoaderCancellationBlock)
+    getImageSizeForURLRequest:(NSURLRequest *)imageURLRequest
+                        block:(void (^)(NSError *error,
+                                        CGSize size))completionBlock;
 /**
- * Determines whether given image URLs are cached locally. The `requests` array is expected
- * to contain objects convertible to NSURLRequest. The return value maps URLs to strings:
- * "disk" for images known to be cached in non-volatile storage, "memory" for images known
- * to be cached in memory. Dictionary items corresponding to images that are not known to be
- * cached are simply missing.
+ * Determines whether given image URLs are cached locally. The `requests` array
+ * is expected to contain objects convertible to NSURLRequest. The return value
+ * maps URLs to strings: "disk" for images known to be cached in non-volatile
+ * storage, "memory" for images known to be cached in memory. Dictionary items
+ * corresponding to images that are not known to be cached are simply missing.
  */
 - (NSDictionary *)getImageCacheStatus:(NSArray *)requests;
 
diff --git a/node_modules/react-native/Libraries/Image/RCTImageURLLoader.h b/node_modules/react-native/Libraries/Image/RCTImageURLLoader.h
index a1f2144..0a82788 100644
--- a/node_modules/react-native/Libraries/Image/RCTImageURLLoader.h
+++ b/node_modules/react-native/Libraries/Image/RCTImageURLLoader.h
@@ -35,13 +35,14 @@ typedef dispatch_block_t RCTImageLoaderCancellationBlock;
  * has finished. The method should also return a cancellation block, if
  * applicable.
  */
-- (RCTImageLoaderCancellationBlock)loadImageForURL:(NSURL *)imageURL
-                                              size:(CGSize)size
-                                             scale:(CGFloat)scale
-                                        resizeMode:(RCTResizeMode)resizeMode
-                                   progressHandler:(RCTImageLoaderProgressBlock)progressHandler
-                                partialLoadHandler:(RCTImageLoaderPartialLoadBlock)partialLoadHandler
-                                 completionHandler:(RCTImageLoaderCompletionBlock)completionHandler;
+- (nullable RCTImageLoaderCancellationBlock)
+       loadImageForURL:(NSURL *)imageURL
+                  size:(CGSize)size
+                 scale:(CGFloat)scale
+            resizeMode:(RCTResizeMode)resizeMode
+       progressHandler:(RCTImageLoaderProgressBlock)progressHandler
+    partialLoadHandler:(RCTImageLoaderPartialLoadBlock)partialLoadHandler
+     completionHandler:(RCTImageLoaderCompletionBlock)completionHandler;
 
 @optional
 
@@ -55,12 +56,12 @@ typedef dispatch_block_t RCTImageLoaderCancellationBlock;
 - (float)loaderPriority;
 
 /**
- * If the loader must be called on the serial url cache queue, and whether the completion
- * block should be dispatched off the main thread. If this is NO, the loader will be
- * called from the main queue. Defaults to YES.
+ * If the loader must be called on the serial url cache queue, and whether the
+ * completion block should be dispatched off the main thread. If this is NO, the
+ * loader will be called from the main queue. Defaults to YES.
  *
- * Use with care: disabling scheduling will reduce RCTImageLoader's ability to throttle
- * network requests.
+ * Use with care: disabling scheduling will reduce RCTImageLoader's ability to
+ * throttle network requests.
  */
 - (BOOL)requiresScheduling;
 
diff --git a/node_modules/react-native/Libraries/Image/RCTLocalAssetImageLoader.mm b/node_modules/react-native/Libraries/Image/RCTLocalAssetImageLoader.mm
index 8669ad3..4bd694e 100644
--- a/node_modules/react-native/Libraries/Image/RCTLocalAssetImageLoader.mm
+++ b/node_modules/react-native/Libraries/Image/RCTLocalAssetImageLoader.mm
@@ -15,40 +15,37 @@
 
 #import "RCTImagePlugins.h"
 
-@interface RCTLocalAssetImageLoader() <RCTTurboModule>
+@interface RCTLocalAssetImageLoader () <RCTTurboModule>
 @end
 
 @implementation RCTLocalAssetImageLoader
 
 RCT_EXPORT_MODULE()
 
-- (BOOL)canLoadImageURL:(NSURL *)requestURL
-{
+- (BOOL)canLoadImageURL:(NSURL *)requestURL {
   return RCTIsLocalAssetURL(requestURL);
 }
 
-- (BOOL)requiresScheduling
-{
+- (BOOL)requiresScheduling {
   // Don't schedule this loader on the URL queue so we can load the
   // local assets synchronously to avoid flickers.
   return NO;
 }
 
-- (BOOL)shouldCacheLoadedImages
-{
+- (BOOL)shouldCacheLoadedImages {
   // UIImage imageNamed handles the caching automatically so we don't want
   // to add it to the image cache.
   return NO;
 }
 
- - (RCTImageLoaderCancellationBlock)loadImageForURL:(NSURL *)imageURL
-                                               size:(CGSize)size
-                                              scale:(CGFloat)scale
-                                         resizeMode:(RCTResizeMode)resizeMode
-                                    progressHandler:(RCTImageLoaderProgressBlock)progressHandler
-                                 partialLoadHandler:(RCTImageLoaderPartialLoadBlock)partialLoadHandler
-                                  completionHandler:(RCTImageLoaderCompletionBlock)completionHandler
-{
+- (nullable RCTImageLoaderCancellationBlock)
+       loadImageForURL:(NSURL *)imageURL
+                  size:(CGSize)size
+                 scale:(CGFloat)scale
+            resizeMode:(RCTResizeMode)resizeMode
+       progressHandler:(RCTImageLoaderProgressBlock)progressHandler
+    partialLoadHandler:(RCTImageLoaderPartialLoadBlock)partialLoadHandler
+     completionHandler:(RCTImageLoaderCompletionBlock)completionHandler {
   UIImage *image = RCTImageFromLocalAssetURL(imageURL);
   if (image) {
     if (progressHandler) {
@@ -56,7 +53,8 @@ - (RCTImageLoaderCancellationBlock)loadImageForURL:(NSURL *)imageURL
     }
     completionHandler(nil, image);
   } else {
-    NSString *message = [NSString stringWithFormat:@"Could not find image %@", imageURL];
+    NSString *message =
+        [NSString stringWithFormat:@"Could not find image %@", imageURL];
     RCTLogWarn(@"%@", message);
     completionHandler(RCTErrorWithMessage(message), nil);
   }
diff --git a/node_modules/react-native/Libraries/Network/RCTNetworkTask.mm b/node_modules/react-native/Libraries/Network/RCTNetworkTask.mm
index 1cc6252..438d61e 100644
--- a/node_modules/react-native/Libraries/Network/RCTNetworkTask.mm
+++ b/node_modules/react-native/Libraries/Network/RCTNetworkTask.mm
@@ -11,8 +11,7 @@
 #import <React/RCTNetworkTask.h>
 #import <React/RCTUtils.h>
 
-@implementation RCTNetworkTask
-{
+@implementation RCTNetworkTask {
   NSMutableData *_data;
   id<RCTURLRequestHandler> _handler;
   dispatch_queue_t _callbackQueue;
@@ -23,8 +22,7 @@ @implementation RCTNetworkTask
 
 - (instancetype)initWithRequest:(NSURLRequest *)request
                         handler:(id<RCTURLRequestHandler>)handler
-                  callbackQueue:(dispatch_queue_t)callbackQueue
-{
+                  callbackQueue:(dispatch_queue_t)callbackQueue {
   RCTAssertParam(request);
   RCTAssertParam(handler);
   RCTAssertParam(callbackQueue);
@@ -38,15 +36,15 @@ - (instancetype)initWithRequest:(NSURLRequest *)request
     _callbackQueue = callbackQueue;
     _status = RCTNetworkTaskPending;
 
-    dispatch_queue_set_specific(callbackQueue, (__bridge void *)self, (__bridge void *)self, NULL);
+    dispatch_queue_set_specific(callbackQueue, (__bridge void *)self,
+                                (__bridge void *)self, NULL);
   }
   return self;
 }
 
-RCT_NOT_IMPLEMENTED(- (instancetype)init)
+RCT_NOT_IMPLEMENTED(-(instancetype)init)
 
-- (void)invalidate
-{
+- (void)invalidate {
   _selfReference = nil;
   _completionBlock = nil;
   _downloadProgressBlock = nil;
@@ -56,8 +54,7 @@ - (void)invalidate
   _requestToken = nil;
 }
 
-- (void)dispatchCallback:(dispatch_block_t)callback
-{
+- (void)dispatchCallback:(dispatch_block_t)callback {
   if (dispatch_get_specific((__bridge void *)self) == (__bridge void *)self) {
     callback();
   } else {
@@ -65,8 +62,7 @@ - (void)dispatchCallback:(dispatch_block_t)callback
   }
 }
 
-- (void)start
-{
+- (void)start {
   if (_status != RCTNetworkTaskPending) {
     RCTLogError(@"RCTNetworkTask was already started or completed");
     return;
@@ -81,8 +77,7 @@ - (void)start
   }
 }
 
-- (void)cancel
-{
+- (void)cancel {
   if (_status == RCTNetworkTaskFinished) {
     return;
   }
@@ -95,20 +90,14 @@ - (void)cancel
   [self invalidate];
 }
 
-- (BOOL)validateRequestToken:(id)requestToken
-{
+- (BOOL)validateRequestToken:(id)requestToken {
   BOOL valid = YES;
   if (_requestToken == nil) {
-    if (requestToken == nil) {
-      if (RCT_DEBUG) {
-        RCTLogError(@"Missing request token for request: %@", _request);
-      }
-      valid = NO;
-    }
     _requestToken = requestToken;
   } else if (![requestToken isEqual:_requestToken]) {
     if (RCT_DEBUG) {
-      RCTLogError(@"Unrecognized request token: %@ expected: %@", requestToken, _requestToken);
+      RCTLogError(@"Unrecognized request token: %@ expected: %@", requestToken,
+                  _requestToken);
     }
     valid = NO;
   }
@@ -118,7 +107,8 @@ - (BOOL)validateRequestToken:(id)requestToken
     if (_completionBlock) {
       RCTURLRequestCompletionBlock completionBlock = _completionBlock;
       [self dispatchCallback:^{
-        completionBlock(self->_response, nil, RCTErrorWithMessage(@"Invalid request token."));
+        completionBlock(self->_response, nil,
+                        RCTErrorWithMessage(@"Invalid request token."));
       }];
     }
     [self invalidate];
@@ -126,8 +116,7 @@ - (BOOL)validateRequestToken:(id)requestToken
   return valid;
 }
 
-- (void)URLRequest:(id)requestToken didSendDataWithProgress:(int64_t)bytesSent
-{
+- (void)URLRequest:(id)requestToken didSendDataWithProgress:(int64_t)bytesSent {
   if (![self validateRequestToken:requestToken]) {
     return;
   }
@@ -141,8 +130,8 @@ - (void)URLRequest:(id)requestToken didSendDataWithProgress:(int64_t)bytesSent
   }
 }
 
-- (void)URLRequest:(id)requestToken didReceiveResponse:(NSURLResponse *)response
-{
+- (void)URLRequest:(id)requestToken
+    didReceiveResponse:(NSURLResponse *)response {
   if (![self validateRequestToken:requestToken]) {
     return;
   }
@@ -156,8 +145,7 @@ - (void)URLRequest:(id)requestToken didReceiveResponse:(NSURLResponse *)response
   }
 }
 
-- (void)URLRequest:(id)requestToken didReceiveData:(NSData *)data
-{
+- (void)URLRequest:(id)requestToken didReceiveData:(NSData *)data {
   if (![self validateRequestToken:requestToken]) {
     return;
   }
@@ -165,8 +153,9 @@ - (void)URLRequest:(id)requestToken didReceiveData:(NSData *)data
   int64_t length = 0;
 
   {
-    // NSData is not thread-safe and this method could be called from different threads as
-    // RCTURLRequestHandlers does not provide any guarantee of which thread we are called on.
+    // NSData is not thread-safe and this method could be called from different
+    // threads as RCTURLRequestHandlers does not provide any guarantee of which
+    // thread we are called on.
     std::lock_guard<std::mutex> lock(_mutex);
     if (!_data) {
       _data = [NSMutableData new];
@@ -178,7 +167,8 @@ - (void)URLRequest:(id)requestToken didReceiveData:(NSData *)data
   int64_t total = _response.expectedContentLength;
 
   if (_incrementalDataBlock) {
-    RCTURLRequestIncrementalDataBlock incrementalDataBlock = _incrementalDataBlock;
+    RCTURLRequestIncrementalDataBlock incrementalDataBlock =
+        _incrementalDataBlock;
     [self dispatchCallback:^{
       incrementalDataBlock(data, length, total);
     }];
@@ -191,8 +181,7 @@ - (void)URLRequest:(id)requestToken didReceiveData:(NSData *)data
   }
 }
 
-- (void)URLRequest:(id)requestToken didCompleteWithError:(NSError *)error
-{
+- (void)URLRequest:(id)requestToken didCompleteWithError:(NSError *)error {
   if (![self validateRequestToken:requestToken]) {
     return;
   }
diff --git a/node_modules/react-native/scripts/.packager.env b/node_modules/react-native/scripts/.packager.env
new file mode 100644
index 0000000..361f5fb
--- /dev/null
+++ b/node_modules/react-native/scripts/.packager.env
@@ -0,0 +1 @@
+export RCT_METRO_PORT=8081
diff --git a/node_modules/react-native/scripts/react-native-xcode.sh b/node_modules/react-native/scripts/react-native-xcode.sh
index 328085f..da9e44c 100755
--- a/node_modules/react-native/scripts/react-native-xcode.sh
+++ b/node_modules/react-native/scripts/react-native-xcode.sh
@@ -54,17 +54,11 @@ case "$CONFIGURATION" in
     ;;
 esac
 
-# Setting up a project root was a workaround to enable support for non-standard
-# structures, including monorepos. Today, CLI supports that out of the box
-# and setting custom `PROJECT_ROOT` only makes it confusing. 
-#
-# As a backwards-compatible change, I am leaving "PROJECT_ROOT" support for those
-# who already use it - it is likely a non-breaking removal.
-#
-# For new users, we default to $PWD - not changing things all.
-#
-# For context: https://github.com/facebook/react-native/commit/9ccde378b6e6379df61f9d968be6346ca6be7ead#commitcomment-37914902
-PROJECT_ROOT=${PROJECT_ROOT:-$PWD}
+# Path to react-native folder inside node_modules
+REACT_NATIVE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
+# The project should be located next to where react-native is installed
+# in node_modules.
+PROJECT_ROOT=${PROJECT_ROOT:-"$REACT_NATIVE_DIR/../.."}
 
 cd "$PROJECT_ROOT" || exit
 
@@ -102,9 +96,6 @@ if [[ ! -x node && -d ${HOME}/.anyenv/bin ]]; then
   fi
 fi
 
-# Path to react-native folder inside node_modules
-REACT_NATIVE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
-
 # check and assign NODE_BINARY env
 # shellcheck source=/dev/null
 source "$REACT_NATIVE_DIR/scripts/node-binary.sh"
