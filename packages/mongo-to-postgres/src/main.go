package main

import (
  "github.com/globalsign/mgo"
  "os"
  "fmt"
  _ "github.com/lib/pq"
  "strings"
  "github.com/lib/pq"
  "github.com/jmoiron/sqlx"
  "time"
)

func main() {
  start := time.Now()
  // ---- Prepare Mongo

  mongoUri := os.Getenv("MONGO_URI")
  session, err := mgo.Dial(mongoUri)
  if err != nil {
    fmt.Fprintf(os.Stderr, "Couldn't connect to mongo: %s", err.Error())
    os.Exit(1)
  }
  mongo := session.DB("wwdb")

  // ----- Prepare Postgres

  pgConnStr := fmt.Sprintf(
    "postgres://postgres:%s@localhost/%s?sslmode=disable",
    os.Getenv("PGPASSWORD"),
    os.Getenv("POSTGRES_DB"),
  )
  pg, err := sqlx.Open("postgres", pgConnStr)
  if err != nil {
    fmt.Fprintf(os.Stderr, "Couldn't connect to postgres: %s", err.Error())
    os.Exit(1)
  }
  pg.MapperFunc(ToSnake)

  // ----- Clear all tables

  clearPg(pg)

  elapsed := time.Since(start)
  fmt.Printf("Preparation took %s\n", elapsed)
  start = time.Now()

  // ----- Begin migration

  // Mapping between Mongo Ids (they are not Mongo.ObjectIds btw, they are 17bytes generated by Meteor)
  uuids := IdMap{}
  // Mapping between source's Mongo Ids and Scripts
  scripts := IdMap{}
  // Mapping Gauge Mongo Id <--> { Script, Code }
  mKeys := make(GaugesToKeys)

  if err := insertTags(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting tags: %s\n", err.Error())
    os.Exit(1)
  }


  if err := insertUsers(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting users: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertPoints(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting points: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertRegions(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting regions: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertSources(mongo, pg, uuids, scripts); err != nil {
    fmt.Printf("Error while inserting regions: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertGauges(mongo, pg, uuids, scripts, mKeys); err != nil {
    fmt.Printf("Error while inserting gauges: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertRivers(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting rivers: %s\n", err.Error())
    os.Exit(1)
  }

  if err := insertMedia(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting media: %s\n", err.Error())
    os.Exit(1)
  }


  if err := insertSections(mongo, pg, uuids); err != nil {
    fmt.Printf("Error while inserting sections: %s\n", err.Error())
    os.Exit(1)
  }

  elapsed = time.Since(start)
  fmt.Printf("Inserted %d objects in %s\n", len(uuids), elapsed)
  start = time.Now()

  // ----- Measurements
  mCount, err := insertMeasurements(mongo, pg, mKeys)
  if err != nil {
    fmt.Printf("Error while inserting measurements: %s\n", err.Error())
    os.Exit(1)
  }

  elapsed = time.Since(start)
  fmt.Printf("Migrated %d measurements in %s\n", mCount, elapsed)
}

func clearPg(pg *sqlx.DB) {
  tables := []string{
    "sources_regions",
    "logins",
    "users",
    "gauges",
    "gauges_translations",
    "sections",
    "sections_translations",
    "sections_points",
    "sections_tags",
    "sections_media",
    "sources",
    "sources_translations",
    "regions",
    "regions_translations",
    "regions_points",
    "points",
    "points_translations",
    "rivers",
    "rivers_translations",
    "tags",
    "tags_translations",
    "measurements",
    "media",
    "media_translations",
  }
  for i, tbl := range tables {
    tables[i] = pq.QuoteIdentifier(tbl)
  }
  q := fmt.Sprintf("TRUNCATE %s CASCADE", strings.Join(tables, ", "))

  if _, err := pg.Query(q); err != nil {
    fmt.Fprintf(os.Stderr, "Couldn't clear postgres before migrating: %s", err.Error())
    os.Exit(1)
  }
}
