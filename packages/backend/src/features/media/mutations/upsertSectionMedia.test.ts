import { ApolloErrorCodes } from '@whitewater-guide/commons';
import type { MediaInput } from '@whitewater-guide/schema';
import { MediaKind } from '@whitewater-guide/schema';
import { gql } from 'graphql-tag';

import config from '../../../config';
import type { Sql } from '../../../db/index';
import { db, holdTransaction, rollbackTransaction } from '../../../db/index';
import { MEDIA, TEMP } from '../../../s3/index';
import {
  ADMIN,
  ADMIN_ID,
  EDITOR_GA_EC,
  EDITOR_NO_EC,
  EDITOR_NO_EC_ID,
  TEST_USER,
} from '../../../seeds/test/01_users';
import { REGION_NORWAY } from '../../../seeds/test/04_regions';
import { RIVER_SJOA } from '../../../seeds/test/07_rivers';
import {
  GALICIA_BECA_LOWER,
  NORWAY_SJOA_AMOT,
} from '../../../seeds/test/09_sections';
import { PHOTO_1, PHOTO_2 } from '../../../seeds/test/11_media';
import {
  anonContext,
  copyToTemp,
  countRows,
  fakeContext,
  fileExistsInBucket,
  resetTestMinio,
} from '../../../test/index';
import { resolveRelative, UUID_REGEX } from '../../../utils/index';
import { testUpsertSectionMedia } from './upsertSectionMedia.test.generated';

let mBefore: number;
let msBefore: number;
let trBefore: number;

beforeAll(async () => {
  [mBefore, msBefore, trBefore] = await countRows(
    true,
    'media',
    'sections_media',
    'media_translations',
  );
});
beforeEach(async () => {
  await holdTransaction();
  await resetTestMinio();
});
afterEach(rollbackTransaction);
afterAll(() => resetTestMinio(true));

const _mutation = gql`
  mutation upsertSectionMedia($sectionId: ID!, $media: MediaInput!) {
    upsertSectionMedia(sectionId: $sectionId, media: $media) {
      ...MediaCore
      ...TimestampedMeta
      size
    }
  }
`;

const sectionId = NORWAY_SJOA_AMOT;

const NEW_MEDIA_ID = '717b3058-28f0-11e8-b467-0ed5f89f718b';

const media: MediaInput = {
  id: NEW_MEDIA_ID, // always has some id, pregenerated by mediaForm
  description: 'new media description',
  kind: MediaKind.Photo,
  url: NEW_MEDIA_ID,
  resolution: [1920, 1080],
  weight: null,
  license: {
    slug: 'CC_BY-SA',
    name: 'Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)',
    url: 'https://creativecommons.org/licenses/by-sa/4.0/',
  },
  copyright: 'new media copyright',
};

describe('resolvers chain', () => {
  it('anon should not pass', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media },
      anonContext(),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.UNAUTHENTICATED);
  });

  it('user should not pass', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(TEST_USER),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.FORBIDDEN);
  });

  it('non-owning editor should not pass', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_GA_EC),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.FORBIDDEN);
  });

  it('admin should pass', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(ADMIN),
    );
    expect(result).not.toHaveGraphqlError(undefined);
  });

  it('should throw on invalid input', async () => {
    const badMedia = {
      id: 'wtf',
      copyright: 'new media copyright',
      description: 'new media description',
      kind: MediaKind.Photo,
      url: 'zzzzz',
      resolution: [800, 600, 900],
      weight: -10,
    };
    const result = await testUpsertSectionMedia(
      { sectionId, media: badMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).toHaveGraphqlValidationError();
  });
});

describe('insert', () => {
  it('should fail on non-existing section id', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId: '852421bc-2848-11e8-b467-0ed5f89f718b', media },
      fakeContext(ADMIN),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.BAD_USER_INPUT);
  });

  it('should return result', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).not.toHaveGraphqlError();
    expect(result.data?.upsertSectionMedia).toMatchObject({
      copyright: 'new media copyright',
      description: 'new media description',
      id: expect.stringMatching(UUID_REGEX),
      kind: 'photo',
      resolution: [1920, 1080],
      size: 0,
      url: expect.stringContaining('imgproxy://media/'),
      weight: 0,
    });
  });

  it('should add one more media to db', async () => {
    await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      1, 1, 1,
    ]);
  });

  it('should sanitize input', async () => {
    const dirty = { ...media, description: "it's a \\ $1 slash with . ?" };
    const result = await testUpsertSectionMedia(
      { sectionId, media: dirty },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).toHaveProperty(
      'data.upsertSectionMedia.description',
      "it's a \\ $1 slash with . ?",
    );
  });

  it('should set created_by field', async () => {
    await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    const { created_by } = await db(false)
      .table('media')
      .select(['created_by'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(created_by).toBe(EDITOR_NO_EC_ID);
  });

  it('should log this event', async () => {
    await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    const entry: Sql.SectionsEditLog = await db(false)
      .table('sections_edit_log')
      .orderBy('created_at', 'desc')
      .select('*')
      .first();
    expect(entry).toMatchObject({
      id: expect.stringMatching(UUID_REGEX),
      section_id: NORWAY_SJOA_AMOT,
      section_name: 'Amot',
      river_id: RIVER_SJOA,
      river_name: 'Sjoa',
      region_id: REGION_NORWAY,
      region_name: 'Norway',
      editor_id: EDITOR_NO_EC_ID,
      action: 'media_create',
      diff: null,
      created_at: expect.any(Date),
    });
  });
});

describe('update', () => {
  const uMedia = { ...media, id: PHOTO_1 };

  it('should fail on wrong section id', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId: GALICIA_BECA_LOWER, media: uMedia },
      fakeContext(EDITOR_GA_EC),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.BAD_USER_INPUT);
  });

  it('should return result', async () => {
    const result = await testUpsertSectionMedia(
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.errors).toBeUndefined();
    expect(result.data?.upsertSectionMedia).toMatchObject({
      copyright: 'new media copyright',
      description: 'new media description',
      id: expect.stringMatching(UUID_REGEX),
      kind: 'photo',
      resolution: [1920, 1080],
      size: 0,
      url: expect.stringContaining('imgproxy://media/'),
      weight: 0,
    });
  });

  it('should not change db counts', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0, 0, 0,
    ]);
  });

  it('should not change media kind', async () => {
    const badMedia = { ...uMedia, kind: MediaKind.Blog };
    const result = await testUpsertSectionMedia(
      { sectionId, media: badMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.errors).toBeUndefined();
    expect(result).toHaveProperty('data.upsertSectionMedia.kind', 'photo');
  });

  it('should not modify created_by', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const { created_by } = await db(false)
      .table('media')
      .select(['created_by'])
      .where({ id: uMedia.id })
      .first();
    expect(created_by).toBe(ADMIN_ID);
  });

  it('should log this event', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const entry: Sql.SectionsEditLog = await db(false)
      .table('sections_edit_log')
      .orderBy('created_at', 'desc')
      .select('*')
      .first();
    expect(entry).toMatchObject({
      id: expect.stringMatching(UUID_REGEX),
      section_id: NORWAY_SJOA_AMOT,
      section_name: 'Amot',
      river_id: RIVER_SJOA,
      river_name: 'Sjoa',
      region_id: REGION_NORWAY,
      region_name: 'Norway',
      editor_id: EDITOR_NO_EC_ID,
      action: 'media_update',
      diff: expect.any(Object),
      created_at: expect.any(Date),
    });
  });

  it('should accept absolute photo urls', async () => {
    const result = await testUpsertSectionMedia(
      {
        sectionId,
        media: {
          ...uMedia,
          copyright: 'foo',
          url: `${config.contentPublicURL}/${NEW_MEDIA_ID}`,
        },
      },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.data?.upsertSectionMedia?.copyright).toBe('foo');
    expect(result.data?.upsertSectionMedia?.url).toBe(
      `imgproxy://media/${NEW_MEDIA_ID}`,
    );
  });
});

describe('i18n', () => {
  const aMedia = { ...media, id: PHOTO_2 };
  const uMedia = { ...media, id: PHOTO_1 };

  it('should add new translation', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: aMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0, 0, 1,
    ]);
  });

  it('should modify common props in other language', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: aMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const { resolution } = await db()
      .table('media_view')
      .select('resolution')
      .where({ id: PHOTO_2, language: 'en' })
      .first();
    expect(resolution).toMatchObject([1920, 1080]);
  });

  it('should modify existing translation', async () => {
    await testUpsertSectionMedia(
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0, 0, 0,
    ]);
    const { description } = await db()
      .table('media_view')
      .select('description')
      .where({ id: PHOTO_1, language: 'ru' })
      .first();
    expect(description).toBe('new media description');
  });
});

describe('files', () => {
  let result: any;

  beforeEach(async () => {
    // Emulate file with the same key as existing avatar uploaded by user
    await copyToTemp(
      resolveRelative(__dirname, '__tests__/test.jpg'),
      NEW_MEDIA_ID,
    );
    result = await testUpsertSectionMedia(
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
  });

  it('should move files from temp to media', async () => {
    await expect(fileExistsInBucket(TEMP, 'test.jpg')).resolves.toBe(false);
    await expect(fileExistsInBucket(TEMP, NEW_MEDIA_ID)).resolves.toBe(false);
    // expect items bucket to contain new_image.jpg
    await expect(
      fileExistsInBucket(
        MEDIA,
        NEW_MEDIA_ID,
        'a1c4720fa8526d4a8560dd1cb29c0ea7',
      ),
    ).resolves.toBe(true);
  });

  it('should store only filenames', async () => {
    const { url } = await db()
      .table('media')
      .select(['url'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(url).toBe(NEW_MEDIA_ID);
  });

  it('should store media size', async () => {
    const { size } = await db()
      .table('media')
      .select(['size'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(size).toBe(14935);
  });

  it('should return full url', () => {
    expect(result.errors).toBeUndefined();
    const { url } = result.data.upsertSectionMedia;
    expect(url).toBe(`imgproxy://media/${NEW_MEDIA_ID}`);
  });

  it('should return media size', () => {
    expect(result).toHaveProperty('data.upsertSectionMedia.size', 14935);
  });
});
