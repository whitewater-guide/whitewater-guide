import { copy } from 'fs-extra';
import path from 'path';
import db, { holdTransaction, rollbackTransaction } from '../../../db';
import { fileExistsInBucket, MEDIA, resetTestMinio, TEMP, TEMP_BUCKET_DIR } from '../../../minio';
import { ADMIN, ADMIN_ID, EDITOR_GA_EC, EDITOR_NO_EC, EDITOR_NO_EC_ID, TEST_USER } from '../../../seeds/test/01_users';
import { GALICIA_R1_S1, NORWAY_SJOA_AMOT } from '../../../seeds/test/09_sections';
import { PHOTO_1, PHOTO_2 } from '../../../seeds/test/11_media';
import { anonContext, fakeContext } from '../../../test/context';
import { countRows, noTimestamps, noUnstable, runQuery } from '../../../test/db-helpers';
import { MediaInput, MediaKind } from '../../../ww-commons/features/media';

let mBefore: number;
let msBefore: number;
let trBefore: number;

beforeAll(async () => {
  [mBefore, msBefore, trBefore] = await countRows(true, 'media', 'sections_media', 'media_translations');
});
beforeEach(async () => {
  await holdTransaction();
  await resetTestMinio();
});
afterEach(rollbackTransaction);
afterAll(() => resetTestMinio(true));

const mutation = `
  mutation upsertSectionMedia($sectionId: ID!, $media: MediaInput!){
    upsertSectionMedia(sectionId: $sectionId, media: $media){
      id
      kind
      description
      copyright
      url
      resolution
      weight
      createdAt
      updatedAt
    }
  }
`;

const sectionId = NORWAY_SJOA_AMOT;

const NEW_MEDIA_ID = '717b3058-28f0-11e8-b467-0ed5f89f718b';

const media: MediaInput = {
  id: NEW_MEDIA_ID, // always has some id, pregenerated by mediaForm
  copyright: 'new media copyright',
  description: 'new media description',
  kind: MediaKind.photo,
  url: NEW_MEDIA_ID,
  resolution: [1920, 1080],
  weight: null,
};

describe('resolvers chain', () => {
  it('anon should not pass', async () => {
    const result = await runQuery(mutation, { sectionId, media }, anonContext());
    expect(result).toHaveProperty('errors.0.name', 'AuthenticationRequiredError');
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
  });

  it('user should not pass', async () => {
    const result = await runQuery(mutation, { sectionId, media }, fakeContext(TEST_USER));
    expect(result).toHaveProperty('errors.0.name', 'ForbiddenError');
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
  });

  it('non-owning editor should not pass', async () => {
    const result = await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_GA_EC));
    expect(result).toHaveProperty('errors.0.name', 'ForbiddenError');
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
  });

  it('admn should pass', async () => {
    const result = await runQuery(mutation, { sectionId, media }, fakeContext(ADMIN));
    expect(result.errors).toBeUndefined();
    expect(result.data!.upsertSectionMedia).toBeDefined();
  });

  it('should throw on invalid input', async () => {
    const badMedia = {
      id: 'wtf',
      copyright: 'new media copyright',
      description: 'new media description',
      kind: MediaKind.photo,
      url: 'zzzzz',
      resolution: [800, 600, 900],
      weight: -10,
    };
    const result = await runQuery(mutation, { sectionId, media: badMedia }, fakeContext(EDITOR_NO_EC));
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
    expect(result).toHaveProperty('errors.0.name', 'ValidationError');
    expect((result.errors![0] as any).data).toMatchSnapshot();
  });

});

describe('insert', () => {
  it('should fail on non-existing section id', async () => {
    const result = await runQuery(mutation, { sectionId: '852421bc-2848-11e8-b467-0ed5f89f718b', media }, fakeContext(EDITOR_NO_EC));
    expect(result).toHaveProperty('errors.0.name', 'ForbiddenError');
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
  });

  it('should return result', async () => {
    const result = await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    expect(result.errors).toBeUndefined();
    expect(noTimestamps(result.data)).toMatchSnapshot();
  });

  it('should add one more media to db', async () => {
    await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    const [m, ms, tr] = await countRows(false, 'media', 'sections_media', 'media_translations');
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([1, 1, 1]);
  });

  it('should sanitize input', async () => {
    const dirty = { ...media, description: "it's a \\ $1 slash with . ?" };
    const result = await runQuery(mutation, { sectionId, media: dirty }, fakeContext(EDITOR_NO_EC));
    expect(result).toHaveProperty('data.upsertSectionMedia.description', "it's a \\ $1 slash with . ?");
  });

  it('should set created_by field', async () => {
    await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    const { created_by } = await db(false).table('media').select(['created_by']).where({ id: NEW_MEDIA_ID }).first();
    expect(created_by).toBe(EDITOR_NO_EC_ID);
  });
});

describe('update', () => {
  const uMedia = { ...media, id: PHOTO_1 };

  it('should fail on wrong section id', async () => {
    const result = await runQuery(mutation, { sectionId: GALICIA_R1_S1, media: uMedia }, fakeContext(EDITOR_NO_EC));
    expect(result).toHaveProperty('errors.0.name', 'ForbiddenError');
    expect(result).toHaveProperty('data.upsertSectionMedia', null);
  });

  it('should return result', async () => {
    const result = await runQuery(mutation, { sectionId, media: uMedia }, fakeContext(EDITOR_NO_EC));
    expect(result.errors).toBeUndefined();
    expect(noUnstable(result.data)).toMatchSnapshot();
  });

  it('should not change db counts', async () => {
    await runQuery(mutation, { sectionId, media: uMedia }, fakeContext(EDITOR_NO_EC));
    const [m, ms, tr] = await countRows(false, 'media', 'sections_media', 'media_translations');
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([0, 0, 0]);
  });

  it('should not change media kind', async () => {
    const badMedia = { ...uMedia, kind: 'blog' };
    const result = await runQuery(mutation, { sectionId, media: badMedia }, fakeContext(EDITOR_NO_EC));
    expect(result.errors).toBeUndefined();
    expect(result).toHaveProperty('data.upsertSectionMedia.kind', 'photo');
  });

  it('should not modify created_by', async () => {
    await runQuery(mutation, { sectionId, media: uMedia }, fakeContext(EDITOR_NO_EC));
    const { created_by } = await db(false).table('media').select(['created_by'])
      .where({ id: uMedia.id }).first();
    expect(created_by).toBe(ADMIN_ID);
  });
});

describe('i18n', () => {
  const aMedia = { ...media, id: PHOTO_2 };
  const uMedia = { ...media, id: PHOTO_1 };

  it('should add new translation', async () => {
    await runQuery(mutation, { sectionId, media: aMedia }, fakeContext(EDITOR_NO_EC, 'ru'));
    const [m, ms, tr] = await countRows(false, 'media', 'sections_media', 'media_translations');
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([0, 0, 1]);
  });

  it('should modify common props in other language', async () => {
    await runQuery(mutation, { sectionId, media: aMedia }, fakeContext(EDITOR_NO_EC, 'ru'));
    const { resolution } = await db().table('media_view').select('resolution')
      .where({ id: PHOTO_2, language: 'en' }).first();
    expect(resolution).toMatchObject([1920, 1080]);
  });

  it('should modify existing translation', async () => {
    await runQuery(mutation, { sectionId, media: uMedia }, fakeContext(EDITOR_NO_EC, 'ru'));
    const [m, ms, tr] = await countRows(false, 'media', 'sections_media', 'media_translations');
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([0, 0, 0]);
    const { description } = await db().table('media_view').select('description')
      .where({ id: PHOTO_1, language: 'ru' }).first();
    expect(description).toBe('new media description');
  });
});

describe('files', () => {
  let result: any;

  beforeEach(async () => {
    // Emulate file with the same key as existing avatar uploaded by user
    await copy(
      path.resolve(__dirname, '__tests__/test.jpg'),
      path.resolve(TEMP_BUCKET_DIR, NEW_MEDIA_ID),
    );
    result = await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    expect(result.errors).toBeUndefined();
  });

  it('should move files from temp to media', async () => {
    await expect(fileExistsInBucket(TEMP, 'test.jpg')).resolves.toBe(false);
    await expect(fileExistsInBucket(TEMP, NEW_MEDIA_ID)).resolves.toBe(false);
    // expect items bucket to contain new_image.jpg
    await expect(fileExistsInBucket(MEDIA, NEW_MEDIA_ID, 'a1c4720fa8526d4a8560dd1cb29c0ea7'))
      .resolves.toBe(true);
  });

  it('should store only filenames', async () => {
    const { url } = await db().table('media').select(['url']).where({ id: NEW_MEDIA_ID }).first();
    expect(url).toBe(NEW_MEDIA_ID);
  });

  it('should return filename as url', async () => {
    expect(result).toHaveProperty('data.upsertSectionMedia.url', NEW_MEDIA_ID);
  });
});
