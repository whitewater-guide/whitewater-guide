import db, { holdTransaction, rollbackTransaction } from '@db';
import { SectionsEditLogRaw } from '@features/sections';
import {
  fileExistsInBucket,
  MEDIA,
  resetTestMinio,
  TEMP,
  TEMP_BUCKET_DIR,
} from '@minio';
import {
  ADMIN,
  ADMIN_ID,
  EDITOR_GA_EC,
  EDITOR_NO_EC,
  EDITOR_NO_EC_ID,
  TEST_USER,
} from '@seeds/01_users';
import { REGION_NORWAY } from '@seeds/04_regions';
import { RIVER_SJOA } from '@seeds/07_rivers';
import { GALICIA_R1_S1, NORWAY_SJOA_AMOT } from '@seeds/09_sections';
import { PHOTO_1, PHOTO_2 } from '@seeds/11_media';
import {
  anonContext,
  countRows,
  fakeContext,
  noTimestamps,
  noUnstable,
  runQuery,
  UUID_REGEX,
} from '@test';
import {
  ApolloErrorCodes,
  MediaInput,
  MediaKind,
} from '@whitewater-guide/commons';
import { copy } from 'fs-extra';
import * as path from 'path';

let mBefore: number;
let msBefore: number;
let trBefore: number;

beforeAll(async () => {
  [mBefore, msBefore, trBefore] = await countRows(
    true,
    'media',
    'sections_media',
    'media_translations',
  );
});
beforeEach(async () => {
  await holdTransaction();
  await resetTestMinio();
});
afterEach(rollbackTransaction);
afterAll(() => resetTestMinio(true));

const mutation = `
  mutation upsertSectionMedia($sectionId: ID!, $media: MediaInput!){
    upsertSectionMedia(sectionId: $sectionId, media: $media){
      id
      kind
      description
      copyright
      url
      resolution
      weight
      createdAt
      updatedAt
      size
    }
  }
`;

const sectionId = NORWAY_SJOA_AMOT;

const NEW_MEDIA_ID = '717b3058-28f0-11e8-b467-0ed5f89f718b';

const media: MediaInput = {
  id: NEW_MEDIA_ID, // always has some id, pregenerated by mediaForm
  copyright: 'new media copyright',
  description: 'new media description',
  kind: MediaKind.photo,
  url: NEW_MEDIA_ID,
  resolution: [1920, 1080],
  weight: null,
};

describe('resolvers chain', () => {
  it('anon should not pass', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media },
      anonContext(),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.UNAUTHENTICATED);
  });

  it('user should not pass', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media },
      fakeContext(TEST_USER),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.FORBIDDEN);
  });

  it('non-owning editor should not pass', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media },
      fakeContext(EDITOR_GA_EC),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.FORBIDDEN);
  });

  it('admin should pass', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media },
      fakeContext(ADMIN),
    );
    expect(result).not.toHaveGraphqlError(undefined);
  });

  it('should throw on invalid input', async () => {
    const badMedia = {
      id: 'wtf',
      copyright: 'new media copyright',
      description: 'new media description',
      kind: MediaKind.photo,
      url: 'zzzzz',
      resolution: [800, 600, 900],
      weight: -10,
    };
    const result = await runQuery(
      mutation,
      { sectionId, media: badMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).toHaveGraphqlValidationError();
  });
});

describe('insert', () => {
  it('should fail on non-existing section id', async () => {
    const result = await runQuery(
      mutation,
      { sectionId: '852421bc-2848-11e8-b467-0ed5f89f718b', media },
      fakeContext(ADMIN),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.BAD_USER_INPUT);
  });

  it('should return result', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).not.toHaveGraphqlError();
    expect(noTimestamps(result.data)).toMatchSnapshot();
  });

  it('should add one more media to db', async () => {
    await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      1,
      1,
      1,
    ]);
  });

  it('should sanitize input', async () => {
    const dirty = { ...media, description: "it's a \\ $1 slash with . ?" };
    const result = await runQuery(
      mutation,
      { sectionId, media: dirty },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result).toHaveProperty(
      'data.upsertSectionMedia.description',
      "it's a \\ $1 slash with . ?",
    );
  });

  it('should set created_by field', async () => {
    await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    const { created_by } = await db(false)
      .table('media')
      .select(['created_by'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(created_by).toBe(EDITOR_NO_EC_ID);
  });

  it('should log this event', async () => {
    await runQuery(mutation, { sectionId, media }, fakeContext(EDITOR_NO_EC));
    const entry: SectionsEditLogRaw = await db(false)
      .table('sections_edit_log')
      .orderBy('created_at', 'desc')
      .select('*')
      .first();
    expect(entry).toMatchObject({
      id: expect.stringMatching(UUID_REGEX),
      section_id: NORWAY_SJOA_AMOT,
      old_section_name: 'Amot',
      new_section_name: 'Amot',
      river_id: RIVER_SJOA,
      river_name: 'Sjoa',
      region_id: REGION_NORWAY,
      region_name: 'Norway',
      editor_id: EDITOR_NO_EC_ID,
      action: 'media_create',
      created_at: expect.any(Date),
    });
  });
});

describe('update', () => {
  const uMedia = { ...media, id: PHOTO_1 };

  it('should fail on wrong section id', async () => {
    const result = await runQuery(
      mutation,
      { sectionId: GALICIA_R1_S1, media: uMedia },
      fakeContext(EDITOR_GA_EC),
    );
    expect(result).toHaveGraphqlError(ApolloErrorCodes.BAD_USER_INPUT);
  });

  it('should return result', async () => {
    const result = await runQuery(
      mutation,
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.errors).toBeUndefined();
    expect(noUnstable(result.data)).toMatchSnapshot();
  });

  it('should not change db counts', async () => {
    await runQuery(
      mutation,
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0,
      0,
      0,
    ]);
  });

  it('should not change media kind', async () => {
    const badMedia = { ...uMedia, kind: 'blog' };
    const result = await runQuery(
      mutation,
      { sectionId, media: badMedia },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.errors).toBeUndefined();
    expect(result).toHaveProperty('data.upsertSectionMedia.kind', 'photo');
  });

  it('should not modify created_by', async () => {
    await runQuery(
      mutation,
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const { created_by } = await db(false)
      .table('media')
      .select(['created_by'])
      .where({ id: uMedia.id })
      .first();
    expect(created_by).toBe(ADMIN_ID);
  });

  it('should log this event', async () => {
    await runQuery(
      mutation,
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC),
    );
    const entry: SectionsEditLogRaw = await db(false)
      .table('sections_edit_log')
      .orderBy('created_at', 'desc')
      .select('*')
      .first();
    expect(entry).toMatchObject({
      id: expect.stringMatching(UUID_REGEX),
      section_id: NORWAY_SJOA_AMOT,
      old_section_name: 'Amot',
      new_section_name: 'Amot',
      river_id: RIVER_SJOA,
      river_name: 'Sjoa',
      region_id: REGION_NORWAY,
      region_name: 'Norway',
      editor_id: EDITOR_NO_EC_ID,
      action: 'media_update',
      created_at: expect.any(Date),
    });
  });
});

describe('i18n', () => {
  const aMedia = { ...media, id: PHOTO_2 };
  const uMedia = { ...media, id: PHOTO_1 };

  it('should add new translation', async () => {
    await runQuery(
      mutation,
      { sectionId, media: aMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0,
      0,
      1,
    ]);
  });

  it('should modify common props in other language', async () => {
    await runQuery(
      mutation,
      { sectionId, media: aMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const { resolution } = await db()
      .table('media_view')
      .select('resolution')
      .where({ id: PHOTO_2, language: 'en' })
      .first();
    expect(resolution).toMatchObject([1920, 1080]);
  });

  it('should modify existing translation', async () => {
    await runQuery(
      mutation,
      { sectionId, media: uMedia },
      fakeContext(EDITOR_NO_EC, 'ru'),
    );
    const [m, ms, tr] = await countRows(
      false,
      'media',
      'sections_media',
      'media_translations',
    );
    expect([m - mBefore, ms - msBefore, tr - trBefore]).toMatchObject([
      0,
      0,
      0,
    ]);
    const { description } = await db()
      .table('media_view')
      .select('description')
      .where({ id: PHOTO_1, language: 'ru' })
      .first();
    expect(description).toBe('new media description');
  });
});

describe('files', () => {
  let result: any;

  beforeEach(async () => {
    // Emulate file with the same key as existing avatar uploaded by user
    await copy(
      path.resolve(__dirname, '__tests__/test.jpg'),
      path.resolve(TEMP_BUCKET_DIR, NEW_MEDIA_ID),
    );
    result = await runQuery(
      mutation,
      { sectionId, media },
      fakeContext(EDITOR_NO_EC),
    );
    expect(result.errors).toBeUndefined();
  });

  it('should move files from temp to media', async () => {
    await expect(fileExistsInBucket(TEMP, 'test.jpg')).resolves.toBe(false);
    await expect(fileExistsInBucket(TEMP, NEW_MEDIA_ID)).resolves.toBe(false);
    // expect items bucket to contain new_image.jpg
    await expect(
      fileExistsInBucket(
        MEDIA,
        NEW_MEDIA_ID,
        'a1c4720fa8526d4a8560dd1cb29c0ea7',
      ),
    ).resolves.toBe(true);
  });

  it('should store only filenames', async () => {
    const { url } = await db()
      .table('media')
      .select(['url'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(url).toBe(NEW_MEDIA_ID);
  });

  it('should store media size', async () => {
    const { size } = await db()
      .table('media')
      .select(['size'])
      .where({ id: NEW_MEDIA_ID })
      .first();
    expect(size).toBe(14935);
  });

  it('should return filename as url', async () => {
    expect(result).toHaveProperty('data.upsertSectionMedia.url', NEW_MEDIA_ID);
  });

  it('should return media size', async () => {
    expect(result).toHaveProperty('data.upsertSectionMedia.size', 14935);
  });
});
